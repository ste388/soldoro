<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dungeon 72 Celle - Responsive</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
  <style>
    body { 
      background-image: url('https://i.imgur.com/HvMSTpG.jpg');
      background-size: cover;
      background-repeat: no-repeat;
      background-attachment: fixed;
      color:#e6e6e6; 
      font-family:Arial, sans-serif; 
      display:flex;
      justify-content: center;
      gap:20px; 
      padding:20px;
      padding-top: 100px;
      align-items: flex-start;
      box-sizing: border-box;
    }
    
    #sticky-controls {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: #1a1915;
      border-radius: 0 0 10px 10px;
      z-index: 1000;
      padding: 10px;
      display: flex;
      gap: 14px;
      justify-content: center;
      align-items: center;
      box-shadow: 0 2px 12px rgba(0,0,0,0.40);
      transition: top 0.3s ease-in-out;
    }
    
    #left, #right { width:240px; display:flex; flex-direction:column; gap:10px; }
    #center-column { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 482px; }
    #board-wrapper {
        width: 100%;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }
    #center {
      display: grid;
      grid-template-columns: repeat(9, 50px);
      gap: 4px;
      width: fit-content;
      background: rgba(20, 19, 15, 0.7);
      border-radius:10px;
      padding: 10px;
      box-shadow:inset 0 0 12px #000;
    }
    #right { align-items:center; }
    button { padding:10px 16px; border:none; border-radius:8px; background:#5a8c56; color:#fff; cursor:pointer; font-size:16px; width:100%; box-sizing: border-box; }
    #left button { min-width: 150px; }
    button:hover { background:#7cb673; }
    button:disabled { background:#555; cursor:not-allowed; }
    
    #sticky-controls button {
      width: auto;
      min-width: 120px;
      margin: 0;
    }
    
    .cell { 
      position: relative;
      width: 50px;
      height: 50px;
      border:2px solid #666; 
      border-radius:6px; 
      background:linear-gradient(145deg, rgba(74, 73, 63, 0.7), rgba(55, 55, 40, 0.7)); 
      user-select:none; 
      box-sizing: border-box;
    }
    .cell-content {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: #bfc5a7;
    }
    .visited { background:linear-gradient(145deg, rgba(73, 95, 79, 0.7), rgba(53, 68, 55, 0.7)); border-color:#708665; color:#a4b999; }
    .current { background:linear-gradient(145deg, rgba(143, 173, 106, 0.8), rgba(110, 133, 71, 0.8)); border-color:#a0d535; color:#eff7d6; box-shadow:0 0 10px #a0d535; }
    .highlighted { border: 3px solid white !important; cursor: pointer; }
    
    .enemy-marker, .bonus-marker, .potion-marker, .gas-marker { position:absolute; width:10px; height:10px; border-radius:50%; border:1px solid #fff; }
    .enemy-marker { top:3px; right:3px; background:red; }
    .bonus-marker { bottom:3px; left:3px; background:gold; }
    .potion-marker { bottom:3px; right:3px; background:deepskyblue; }
    .gas-marker { bottom:3px; left:3px; background:#808080;}
    .skull-marker, .prisoner-marker, .shadow-marker { 
        position:absolute; 
        top:50%; 
        left:50%; 
        transform: translate(-50%, -50%); 
        width: 80%; 
        height: 80%; 
        pointer-events:none; 
        opacity: 0.9; 
    }
    .gem-door-marker { border: 3px solid deepskyblue !important; box-shadow: 0 0 15px deepskyblue; }
    
    #diceResult, #shadowDiceResult { width:80px; height:80px; font-size:48px; font-weight:bold; display:flex; align-items:center; justify-content:center; border:2px solid #a0d535; border-radius:10px; background:linear-gradient(145deg,#6e8547,#8fad6a); color:#d7f39b; }
    #shadowDiceResult { border-color: #993333; background: linear-gradient(145deg, #6b2a2a, #8f4b4b); color: #f3c2c2;}
    #main-message-display { min-height:24px; font-weight:bold; text-align:center; background-color: rgba(0,0,0,0.4); border-radius: 5px; padding: 5px; width:100%; box-sizing: border-box; visibility: hidden; }
    #shadowActionDisplay { display:none; min-height:24px; text-align:center; background-color: rgba(0,0,0,0.4); border-radius: 5px; padding: 5px; width:100%; box-sizing: border-box; margin-top: 10px; }
    
    #discoveriesLog { white-space: pre-line; background:rgba(58, 58, 43, 0.8); border-radius:8px; padding:10px; font-size:14px; min-height: 200px; width: 100%;}
    #playerInfo { 
        text-align:center; 
        padding: 5px 10px; 
        border:2px solid #a0d535; 
        border-radius:10px; 
        background:linear-gradient(145deg,#6e8547,#8fad6a); 
        color:#eff7d6;
        min-width: 180px;
    }
    
    #charForm, #encounterModal, #battleModal, #messageModal { display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background: #3a3a2b; padding:20px; border-radius:10px; box-shadow:0 0 15px #000; z-index:1001; text-align:center; width: 300px; }
    #charForm input { width: calc(100% - 16px); padding:8px; margin:8px 0; border:none; border-radius:6px; font-size:16px; }
    
    #battleModal { z-index: 1050; }
    .battle-unit { margin: 15px 0; border: 1px solid #555; padding: 10px; border-radius: 8px; }
    .battle-name { font-weight: bold; font-size: 20px; margin-bottom: 5px; color: #a0d535; }
    .battle-pf, .battle-attack { font-size: 16px; margin-bottom: 5px; }
    .battle-dice { font-size: 48px; font-weight: bold; min-height: 60px; display:flex; align-items:center; justify-content:center; }
    #battleResult { font-size: 18px; font-weight: bold; min-height: 48px; margin-top: 10px; transition: font-size 0.2s; line-height: 1.2; }
    #battleActionContainer { display:flex; flex-direction:column; gap:10px; }
    
    #inventoryContainer { margin-top: 20px; width: 100%; text-align: center; }
    #inventoryContainer select { width: 100%; padding: 8px; background: #3a3a2b; color: #fff; border: 1px solid #666; border-radius: 6px; }

    #messageModal { background: linear-gradient(135deg, #4a3c26, #2d1f0f); border: 4px solid #8b5e3c; color: #f5deb3; font-family: 'MedievalSharp', cursive; font-size: 22px; }
    #messageModal.victory-modal .modal-content { display: flex; flex-direction: column; align-items: center; }
    #messageModal.victory-modal #messageModalText { font-size: 28px; margin-bottom: 5px; }
    #messageModal.victory-modal #victorySubText { font-size: 18px; margin-bottom: 10px; }
    #messageModal.victory-modal #prisonerStatusText { font-size: 16px; color: #d2b48c; }
    #messageModal button { font-family: 'MedievalSharp', cursive; font-size: 18px; margin-top: 20px; padding: 8px 25px; background-color: #8b5e3c; border-radius: 5px; border: 2px solid #5a3d2e; }
    #messageModal button:hover { background-color: #a3764a; }

    @media (max-width: 1024px) {
      body {
        flex-direction: column;
        padding: 10px;
        padding-top: 160px;
        gap: 10px;
        align-items: stretch;
      }
      #right { order: 1; align-items: stretch; }
      #center-column { 
        order: 2;
        width: 100%;
        align-items: stretch;
      }
      #left { order: 3; }
      #left, #right {
        width: 100%;
        box-sizing: border-box;
      }
      #inventoryContainer { margin-top: 10px; }
      #charForm, #encounterModal, #messageModal { width: 90%; }
      #battleModal {
          padding: 10px;
          justify-content: center;
      }
      .battle-unit { margin: 10px 0; padding: 5px; }
      .battle-name { font-size: 18px; }
      .battle-pf, .battle-attack { font-size: 14px; }
      .battle-dice { font-size: 40px; min-height: 50px; }
      
      #sticky-controls {
        flex-wrap: wrap;
        justify-content: space-around;
      }
      #sticky-controls button {
        flex-basis: 45%;
        min-width: auto;
      }
      #diceResult, #shadowDiceResult {
        flex-basis: 45%;
      }
      #playerInfo {
        flex-basis: 100%;
        margin-top: 5px;
      }
    }
  </style>
</head>
<body>

  <div id="sticky-controls">
      <button id="diceRollBtn">Tira dado</button>
      <div id="diceResult">-</div>
      <div id="playerInfo">Crea un personaggio</div>
  </div>

  <div id="left">
    <button id="saveGameBtn">Salva</button>
    <button id="loadGameBtn" style="display:none;">Carica Partita</button>
    <button id="newGameBtn">Nuova Partita</button>
  </div>
  
  <div id="center-column">
    <div id="main-message-display"></div>
    <div id="board-wrapper">
        <div id="center"></div>
    </div>
    <div id="discoveriesLog"></div>
  </div>

  <div id="right">
    <div id="shadowActionDisplay">
        <div id="shadowTurnName">Turno Ombre</div>
        <div id="shadowDiceResult">-</div>
    </div>
    <div id="inventoryContainer">
        <div style="font-weight: bold; margin-bottom: 5px;">Inventario Pozioni</div>
        <select id="inventorySelect"></select>
        <button id="usePotionBtn" style="margin-top: 8px;">Usa Pozione</button>
    </div>
  </div>

  <div id="charForm">
    <div>Nome personaggio:</div>
    <input type="text" id="charName" placeholder="Nome...">
    <div>PF iniziali:</div>
    <input type="number" id="charHP" value="30" min="1">
    <div style="display:flex; gap:8px; margin-top:10px;">
      <button id="startAdventureBtn">Inizia Avventura</button>
      <button id="cancelCharBtn">Annulla</button>
    </div>
  </div>
  
  <div id="encounterModal">
    <p id="encounterMessage"></p>
    <div id="encounterModal-diceResult"></div>
    <div id="encounterActionBtns"></div>
  </div>

  <div id="battleModal">
    <div class="battle-unit">
        <div id="battlePlayerName" class="battle-name"></div>
        <div id="battlePlayerPF" class="battle-pf"></div>
        <div id="battlePlayerAttack" class="battle-attack">Attacco: 1D6</div>
        <div id="battlePlayerDice" class="battle-dice">-</div>
    </div>
    <div id="battleResult"></div>
    <div class="battle-unit">
        <div id="battleEnemyName" class="battle-name"></div>
        <div id="battleEnemyPF" class="battle-pf"></div>
        <div id="battleEnemyAttack" class="battle-attack">Attacco: 1D6</div>
        <div id="battleEnemyDice" class="battle-dice">-</div>
    </div>
    <div id="battleActionContainer"></div>
  </div>

  <div id="messageModal">
      <div class="modal-content">
          <div id="messageModalText"></div>
          <div id="victorySubText"></div>
          <div id="prisonerStatusText"></div>
      </div>
      <button id="messageModalOkBtn">OK</button>
  </div>


<script>
  const board = document.getElementById('center');
  const discoveriesLog = document.getElementById('discoveriesLog');
  const diceBtn = document.getElementById('diceRollBtn');
  const diceRes = document.getElementById('diceResult');
  const shadowActionDisplay = document.getElementById('shadowActionDisplay');
  const shadowTurnName = document.getElementById('shadowTurnName');
  const shadowDiceRes = document.getElementById('shadowDiceResult');
  const mainMessageDisplay = document.getElementById('main-message-display');
  const playerInfo = document.getElementById('playerInfo');
  const newGameBtn = document.getElementById('newGameBtn');
  const saveGameBtn = document.getElementById('saveGameBtn');
  const loadGameBtn = document.getElementById('loadGameBtn');
  const charForm = document.getElementById('charForm');
  const startAdventureBtn = document.getElementById('startAdventureBtn');
  const cancelCharBtn = document.getElementById('cancelCharBtn');
  const encounterModal = document.getElementById('encounterModal');
  const encounterMessage = document.getElementById('encounterMessage');
  const encounterDiceResult = document.getElementById('encounterModal-diceResult');
  const encounterActionBtns = document.getElementById('encounterActionBtns');
  const battleModal = document.getElementById('battleModal');
  const battlePlayerName = document.getElementById('battlePlayerName');
  const battlePlayerPF = document.getElementById('battlePlayerPF');
  const battlePlayerAttack = document.getElementById('battlePlayerAttack');
  const battlePlayerDice = document.getElementById('battlePlayerDice');
  const battleEnemyName = document.getElementById('battleEnemyName');
  const battleEnemyPF = document.getElementById('battleEnemyPF');
  const battleEnemyAttack = document.getElementById('battleEnemyAttack');
  const battleEnemyDice = document.getElementById('battleEnemyDice');
  const battleResult = document.getElementById('battleResult');
  const battleActionContainer = document.getElementById('battleActionContainer');
  const inventorySelect = document.getElementById('inventorySelect');
  const usePotionBtn = document.getElementById('usePotionBtn');
  const messageModal = document.getElementById('messageModal');
  const messageModalText = document.getElementById('messageModalText');
  const victorySubText = document.getElementById('victorySubText');
  const prisonerStatusText = document.getElementById('prisonerStatusText');
  const messageModalOkBtn = document.getElementById('messageModalOkBtn');
  const stickyControls = document.getElementById('sticky-controls');

  const COLS = 9, CELL_COUNT = 72, ENEMY_COUNT = 12, PRISONER_COUNT = 11, GAS_TRAP_COUNT = 2, GAS_EFFECT_DURATION_CELLS = 5;
  const BONUS_ITEMS = ["Elsa migliorata", "Guanti rinforzati", "Spallacci di cuoio"];
  const POTIONS = [ { name: "Pozione (+5 PF)", value: 5 }, { name: "Pozione (+10 PF)", value: 10 }, { name: "Pozione (+15 PF)", value: 15 } ];
  const GEMS = ["Gemma Blu", "Gemma Verde", "Gemma Viola"];
  const GEM_DOOR = "Porta di Gemme";
  const SHADOW_SPAWNS = [
      { name: "Ombra", hp: 10, attackDie: 6, attackBonus: 0, iconUrl: "https://i.imgur.com/g8dsPn5.png", spawnTurn: 10 },
      { name: "Ombra Paurosa", hp: 15, attackDie: 6, attackBonus: 0, iconUrl: "https://i.imgur.com/1vmaXr9.png", spawnTurn: 25 },
      { name: "Ombra Cattiva", hp: 20, attackDie: 8, attackBonus: 0, iconUrl: "https://i.imgur.com/t3ccoKY.png", spawnTurn: 40 },
      { name: "Ombra Cattivissima", hp: 25, attackDie: 8, attackBonus: 1, iconUrl: "https://i.imgur.com/eOpP7h2.png", spawnTurn: 52 }
  ];
  const NEW_SKULL_ICON_URL = 'https://i.imgur.com/g9mN0pU.jpg';
  const PRISONER_ICON_URL = 'https://i.imgur.com/XW3fJxc.jpg';

  let currentCell, character, maxHP, enemiesDefeatedCount, discoveryCounter;
  let visitedCells, enemyMap, bonusMap, potionMap, prisonerMap, gasTrapPositions, gasActivatedPositions, shadows;
  let gasEffect = { active: false, newCellsVisited: 0 };
  let messageQueue = [];
  
  function getAttackBonus() {
      if (!character) return 0;
      let bonus = character.bonuses.filter(b => !GEMS.includes(b) && b !== GEM_DOOR).length;
      if (gasEffect.active) {
          bonus -= 1;
      }
      return bonus;
  }
  
  function updateInventory() {
    inventorySelect.innerHTML = '';
    character.inventory.forEach((potion, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = potion.name;
        inventorySelect.appendChild(option);
    });
    usePotionBtn.disabled = character.inventory.length === 0;
  }

  function addSkullMarker(cell) {
    const contentDiv = cell.querySelector('.cell-content');
    if (!contentDiv) return;
    Array.from(contentDiv.childNodes).forEach(node => { if (node.nodeType === Node.TEXT_NODE) node.parentNode.removeChild(node); });
    if (!contentDiv.querySelector('.skull-marker')) {
        const img = document.createElement('img');
        img.src = NEW_SKULL_ICON_URL;
        img.className = 'skull-marker';
        contentDiv.appendChild(img);
    }
  }

  function addPrisonerMarker(cell) {
    const contentDiv = cell.querySelector('.cell-content');
    if (!contentDiv) return;
    Array.from(contentDiv.childNodes).forEach(node => { if (node.nodeType === Node.TEXT_NODE) node.parentNode.removeChild(node); });
    if (!contentDiv.querySelector('.prisoner-marker')) {
        const img = document.createElement('img');
        img.src = PRISONER_ICON_URL;
        img.className = 'prisoner-marker';
        contentDiv.appendChild(img);
    }
  }

  function updateDiscoveriesLog() {
    let lines = [];
    const discoveries = [];

    if(visitedCells) {
        lines.push(`Celle esplorate: ${visitedCells.size}`);
        visitedCells.forEach((info, cellNum) => {
            if (info.discoveryOrder !== null && info.discoveryOrder !== undefined) {
                discoveries.push({ cellNum: Number(cellNum), info: info, discoveryOrder: info.discoveryOrder });
            }
        });
    }

    const sortedDiscoveries = discoveries.sort((a, b) => a.discoveryOrder - b.discoveryOrder);
      
    if (sortedDiscoveries.length > 0) {
        lines.push('\n--- Scoperte ---');
        sortedDiscoveries.forEach(({ cellNum, info }) => {
            if (info.enemy) {
                const status = info.defeated ? ' (sconfitto)' : '';
                const hpInfo = (!info.defeated && info.hp < (info.enemy.startHP || 0)) ? ` - PF: ${info.hp}` : '';
                lines.push(`Cella ${cellNum}: ${info.enemy.name}${status}${hpInfo}`);
            } else if (info.bonus) {
                const collected = character.bonuses.includes(info.bonus) ? ' (raccolto)' : '';
                lines.push(`Cella ${cellNum}: ${info.bonus}${collected}`);
            } else if (info.potion) {
                const collected = info.collected ? ' (raccolta)' : '';
                lines.push(`Cella ${cellNum}: ${info.potion.name}${collected}`);
            } else if (info.prisonerFreed) {
                lines.push(`Cella ${cellNum}: Prigioniero liberato`);
            } else if (gasActivatedPositions.has(cellNum)) {
                lines.push(`Cella ${cellNum}: Trappola a Gas (attiva)`);
            }
        });
    } else {
        lines.push(`(Nessuna scoperta ancora)`);
    }

    if (character && character.bonuses.length > 0) {
        lines.push('\n--- Bonus Attivi ---');
        character.bonuses.forEach(b => {
             if (!GEMS.includes(b) && b !== GEM_DOOR) { lines.push(`- ${b} (+1)`); }
        });
    }

    if (gasEffect.active) {
        const remainingCells = GAS_EFFECT_DURATION_CELLS - gasEffect.newCellsVisited;
        lines.push(`- Gas Debolezza (-1 Atk per ${remainingCells} nuove celle)`);
    }
    
    if (character && GEMS.some(gem => character.bonuses.includes(gem))) {
        lines.push('\n--- Gemme Raccolte ---');
        GEMS.forEach(gem => { if (character.bonuses.includes(gem)) { lines.push(`- ${gem}`); } });
    }
    
    if (character && character.prisonersFreed > 0) {
        lines.push(`\nPrigionieri Liberati: ${character.prisonersFreed}`);
    }

    discoveriesLog.textContent = lines.join('\n');
  }
  
  function placeDiscoveries() {
    enemyMap = {}; bonusMap = {}; potionMap = {}; prisonerMap = {}; 
    gasTrapPositions = new Set(); gasActivatedPositions = new Set(); shadows = [];
    let availableCells = Array.from({length: CELL_COUNT}, (_, i) => i + 1);
    availableCells = availableCells.filter(cellNum => cellNum !== 1);

    for (let i = availableCells.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [availableCells[i], availableCells[j]] = [availableCells[j], availableCells[i]];
    }

    for (let i = 0; i < ENEMY_COUNT; i++) { enemyMap[availableCells.pop()] = { name: `Nemico Casuale` }; }
    BONUS_ITEMS.forEach(itemName => { bonusMap[availableCells.pop()] = itemName; });
    POTIONS.forEach(potion => { potionMap[availableCells.pop()] = potion; });
    GEMS.forEach(gem => { bonusMap[availableCells.pop()] = gem; });
    bonusMap[availableCells.pop()] = GEM_DOOR;
    for (let i = 0; i < PRISONER_COUNT; i++) { prisonerMap[availableCells.pop()] = true; }
    for (let i = 0; i < GAS_TRAP_COUNT; i++) { 
        if (availableCells.length > 0) gasTrapPositions.add(availableCells.pop()); 
    }
  }

  function placeBoss() {
      const allCellNumbers = Array.from({length: CELL_COUNT}, (_, i) => i + 1);
      const occupiedCells = new Set(Array.from(visitedCells.keys()).map(Number));
      Object.keys(enemyMap).forEach(k => occupiedCells.add(Number(k)));
      const freeCells = allCellNumbers.filter(num => !occupiedCells.has(num));
      
      if (freeCells.length > 0) {
          const bossCellNum = freeCells[Math.floor(Math.random() * freeCells.length)];
          enemyMap[bossCellNum] = { name: "Boss Finale", isBoss: true };
          messageQueue.push("Un'oscura presenza è apparsa nel dungeon...");
      } else {
          messageQueue.push("Il Boss non trova spazio per apparire!");
      }
  }

  function buildBoard() {
    board.innerHTML = '';
    for (let i = 1; i <= CELL_COUNT; i++) {
        const r = Math.floor((i - 1) / COLS);
        const c = (i - 1) % COLS;
        const cellDiv = document.createElement('div');
        cellDiv.className = 'cell';
        cellDiv.dataset.cellNumber = i;
        cellDiv.dataset.row = r;
        cellDiv.dataset.col = c;
        
        const content = document.createElement('div');
        content.className = 'cell-content';
        content.textContent = i;
        cellDiv.appendChild(content);

        const shadowHere = shadows.find(s => s.position === i && s.hp > 0);
        if (shadowHere) {
             const img = document.createElement('img');
             img.src = shadowHere.iconUrl;
             img.className = 'shadow-marker';
             content.appendChild(img);
        }
        
        if (gasActivatedPositions.has(i)) {
             content.appendChild(Object.assign(document.createElement('div'), {className: 'gas-marker'}));
        }

        if (visitedCells && visitedCells.has(String(i))) {
            cellDiv.classList.add('visited');
            const info = visitedCells.get(String(i));
            if (info.defeated) addSkullMarker(cellDiv);
            if (info.prisonerFreed) addPrisonerMarker(cellDiv);
            if(info.enemy && !info.defeated) { content.appendChild(Object.assign(document.createElement('div'), {className: 'enemy-marker'})); }
            if(info.bonus) { content.appendChild(Object.assign(document.createElement('div'), {className: 'bonus-marker'})); }
            if(info.potion) { content.appendChild(Object.assign(document.createElement('div'), {className: 'potion-marker'})); }
            if (info.bonus === GEM_DOOR) cellDiv.classList.add('gem-door-marker');
        }

        if (currentCell && parseInt(cellDiv.dataset.cellNumber) === parseInt(currentCell.dataset.cellNumber)) {
            cellDiv.classList.add('current');
        }

        board.appendChild(cellDiv);
    }
  }

  function getValidMoves(steps) {
    if (!currentCell) return [];
    const startRow = +currentCell.dataset.row, startCol = +currentCell.dataset.col;
    return [...board.querySelectorAll('.cell')].filter(cell => {
      if (cell === currentCell) return false;
      const r = +cell.dataset.row, c = +cell.dataset.col;
      const dr = Math.abs(r - startRow), dc = Math.abs(c - startCol);
      return Math.max(dr, dc) === steps;
    });
  }

  function clearHighlights() {
    board.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));
  }

  function getPrisonerStatusMessage() {
      const freed = character.prisonersFreed;
      if (freed === 11) return `Prigionieri liberati: ${freed}. Sei stato portato a festa come un eroe liberatore!`;
      if (freed >= 9) return `Prigionieri liberati: ${freed}. Un cittadino piange il figlio perduto sulla sua tomba.`;
      if (freed >= 5) return `Prigionieri liberati: ${freed}. I cittadini sono tristi per i prigionieri non liberati.`;
      return `Prigionieri liberati: ${freed}. I cittadini piangono i loro cari non liberati.`;
  }

  function processMessageQueue() {
    messageModal.classList.remove('victory-modal');
    victorySubText.textContent = ''; prisonerStatusText.textContent = '';
    if (messageQueue.length > 0) {
        const message = messageQueue.shift();
        if (typeof message === 'object' && message.victory) {
            messageModal.classList.add('victory-modal');
            messageModalText.textContent = message.title;
            victorySubText.textContent = message.subtitle;
            prisonerStatusText.textContent = message.prisonerStatus;
        } else {
            messageModalText.textContent = message;
        }
        messageModal.style.display = 'block';
        messageModalOkBtn.focus();
    } else {
        messageModal.style.display = 'none';
        updatePlayerInfo();
        updateDiscoveriesLog();
    }
  }

  function setMainMessage(text, color = '#ffcc00') {
      mainMessageDisplay.textContent = text;
      mainMessageDisplay.style.color = color;
      mainMessageDisplay.style.visibility = text ? 'visible' : 'hidden';
  }

  function resetMessages() {
      setMainMessage('');
  }

  function setBattleMode(isBattle) {
      if (isBattle) {
          stickyControls.style.top = '-200px';
      } else {
          stickyControls.style.top = '0';
      }
  }

  function findPath(start, end) {
      let queue = [[start]];
      let visited = new Set([start]);
      while(queue.length > 0) {
          let path = queue.shift();
          let pos = path[path.length - 1];
          if(pos === end) return path;

          let neighbors = [pos - 1, pos + 1, pos - COLS, pos + COLS].filter(n => {
              if (n < 1 || n > CELL_COUNT || visited.has(n)) return false;
              const r1 = Math.floor((pos - 1) / COLS), c1 = (pos - 1) % COLS;
              const r2 = Math.floor((n - 1) / COLS), c2 = (n - 1) % COLS;
              return Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1;
          });

          neighbors.sort((a, b) => {
              const distA = Math.abs(Math.floor((a - 1) / COLS) - Math.floor((end - 1) / COLS)) + Math.abs(((a - 1) % COLS) - ((end - 1) % COLS));
              const distB = Math.abs(Math.floor((b - 1) / COLS) - Math.floor((end - 1) / COLS)) + Math.abs(((b - 1) % COLS) - ((end - 1) % COLS));
              return distA - distB;
          });

          for(const neighbor of neighbors) {
              if (!visited.has(neighbor)) {
                visited.add(neighbor);
                let newPath = [...path, neighbor];
                queue.push(newPath);
              }
          }
      }
      return []; 
  }

  async function setCurrent(cell) {
    if (currentCell) currentCell.classList.remove('current');
    currentCell = cell;
    
    const cellNum = parseInt(currentCell.dataset.cellNumber);
    resetMessages();
    const isNewVisit = !visitedCells.has(String(cellNum));

    if (isNewVisit) {
        
        if (gasEffect.active) {
            gasEffect.newCellsVisited++;
            if (gasEffect.newCellsVisited >= GAS_EFFECT_DURATION_CELLS) {
                gasEffect.active = false;
                gasEffect.newCellsVisited = 0;
                messageQueue.push("L'effetto del gas di debolezza è svanito!");
            }
        }
        
        const enemyObj = enemyMap[cellNum];
        const bonusLabel = bonusMap[cellNum];
        const potionLabel = potionMap[cellNum];
        const isPrisonerCell = prisonerMap[cellNum];
        
        let order = discoveryCounter++;

        visitedCells.set(String(cellNum), { 
            enemy: enemyObj || null, bonus: bonusLabel || null, potion: potionLabel || null, 
            prisonerFreed: false, collected: false, defeated: false, hp: 0, discoveryOrder: order
        });
        
        const exploredCount = visitedCells.size;
        if (exploredCount > 0 && exploredCount % 7 === 0) {
            character.hp = Math.min(character.hp + 5, maxHP);
            messageQueue.push("Il riposo ti ha fatto guadagnare 5 PF.");
        }
        
        const info = visitedCells.get(String(cellNum));
        
        if (gasTrapPositions.has(cellNum) && !gasActivatedPositions.has(cellNum)) {
            messageQueue.push(`Sei finito in una trappola a gas! Attacco -1 finché non scopri ${GAS_EFFECT_DURATION_CELLS} nuove celle.`);
            gasEffect.active = true;
            gasEffect.newCellsVisited = 0;
            gasActivatedPositions.add(cellNum);
        }

        if (info.bonus && !character.bonuses.includes(info.bonus)) {
            character.bonuses.push(info.bonus);
            if (GEMS.includes(info.bonus)) { messageQueue.push(`Hai trovato una ${info.bonus}!`); } 
            else if (info.bonus === GEM_DOOR) {
                 const hasAllGems = GEMS.every(gem => character.bonuses.includes(gem));
                 if (hasAllGems && !character.hasSpecialSword) {
                     character.hasSpecialSword = true;
                     messageQueue.push("La Porta si apre! Hai trovato la Spada Speciale (1D8+1).");
                 } else if (character.hasSpecialSword) { setMainMessage("La porta di gemme è vuota.", '#ffffff'); } 
                 else { messageQueue.push("Trovi una porta incastonata di gemme. È sigillata."); }
            } else { messageQueue.push(`Hai trovato: ${info.bonus}! Ottieni +1 in attacco.`); }
        }
        
        if (info.potion && !info.collected) {
            character.inventory.push(info.potion);
            info.collected = true;
            messageQueue.push(`Hai trovato: ${info.potion.name}.`);
            updateInventory();
        }

        if (isPrisonerCell) {
            character.prisonersFreed++;
            info.prisonerFreed = true;
            addPrisonerMarker(cell);
            messageQueue.push("Hai liberato un prigioniero!");
        }

    } else { 
        const info = visitedCells.get(String(cellNum));
        if (info && info.bonus === GEM_DOOR) {
            const hasAllGems = GEMS.every(gem => character.bonuses.includes(gem));
            if (hasAllGems && !character.hasSpecialSword) {
                character.hasSpecialSword = true;
                messageQueue.push("Usi le gemme. La Porta si apre! Trovi la Spada Speciale (1D8+1).");
            }
        }
    }
    
    buildBoard();
    processMessageQueue();
    const info = visitedCells.get(String(cellNum));
    
    const shadowAtLocation = shadows.find(s => s.position === cellNum && s.hp > 0);
    if (shadowAtLocation) {
        startBattle(shadowAtLocation);
        return;
    }

    if (info && info.enemy && !info.defeated) { handleEncounter(info.enemy); } else {
        await handleShadowSpawnsAndTurns();
    }
    
    if (info && info.enemy && info.defeated) {
        setMainMessage(`Qui giace un nemico sconfitto.`, '#a9a9a9');
    } 
    else if (info && !info.enemy && !info.bonus && !info.potion && !prisonerMap[cellNum]) {
        if (isNewVisit || cellNum === 1) { setMainMessage("Procedi tranquillo", 'lightgreen'); } 
        else { setMainMessage('Cella già visitata', '#ffffff'); }
    }

    updatePlayerInfo();
    updateDiscoveriesLog();
  }

  async function handleShadowSpawnsAndTurns() {
      let battleStarted = false;
      const exploredCount = visitedCells.size;

      for (const spawn of SHADOW_SPAWNS) {
          if (exploredCount >= spawn.spawnTurn && !shadows.some(s => s.name === spawn.name)) {
              let freeCells = Array.from({length: CELL_COUNT}, (_, i) => i + 1).filter(c => c !== parseInt(currentCell.dataset.cellNumber) && !shadows.some(s => s.position === c));
              if (freeCells.length > 0) {
                  const pos = freeCells[Math.floor(Math.random() * freeCells.length)];
                  shadows.push({ ...spawn, hp: spawn.hp, startHP: spawn.hp, position: pos, isShadow: true });
                  messageQueue.push(`${spawn.name} è apparsa nel dungeon!`);
                  processMessageQueue();
                  buildBoard();
              }
          }
      }

      if (shadows.some(s => s.hp > 0)) {
          shadowActionDisplay.style.display = 'block';
          for (const shadow of shadows) {
            if (shadow.hp > 0) {
                await new Promise(resolve => setTimeout(resolve, 1000));
                shadowTurnName.textContent = shadow.name;
                const moveRoll = Math.floor(Math.random() * 6) + 1;
                shadowDiceRes.textContent = moveRoll;
                await new Promise(resolve => setTimeout(resolve, 500));

                for (let i = 0; i < moveRoll; i++) {
                    if (battleStarted) break;
                    let path = findPath(shadow.position, parseInt(currentCell.dataset.cellNumber));
                    if (path.length > 1) {
                        shadow.position = path[1];
                        buildBoard();
                        await new Promise(resolve => setTimeout(resolve, 200));
                        if (shadow.position === parseInt(currentCell.dataset.cellNumber)) {
                            startBattle(shadow);
                            battleStarted = true;
                            break;
                        }
                    }
                }
            }
            if(battleStarted) break;
          }
          shadowActionDisplay.style.display = 'none';
      }
      
      if (!battleStarted) diceBtn.disabled = false;
  }

  function handleEncounter(enemy) {
    diceBtn.disabled = true;
    encounterModal.style.display = 'block';
    encounterMessage.textContent = `Nemico! Scegli la tua azione.`;
    encounterActionBtns.innerHTML = ''; 

    const rollBtn = document.createElement('button');
    rollBtn.textContent = 'Tenta di nasconderti (D6)';
    rollBtn.onclick = () => {
        rollBtn.disabled = true; battleBtn.disabled = true;
        let flips = 10;
        const timer = setInterval(() => {
            encounterDiceResult.textContent = Math.floor(Math.random() * 6) + 1;
            if (--flips <= 0) {
                clearInterval(timer);
                const roll = Number(encounterDiceResult.textContent);
                encounterActionBtns.innerHTML = '';
                const closeBtn = document.createElement('button');
                if (roll <= 3) {
                    encounterMessage.textContent = `Sei stato visto! Inizia la battaglia.`;
                    closeBtn.textContent = 'Vai alla Battaglia';
                    closeBtn.onclick = () => { encounterModal.style.display = 'none'; startBattle(enemy); };
                } else {
                    encounterMessage.textContent = 'Sei riuscito a nasconderti!';
                    closeBtn.textContent = 'Chiudi e continua';
                    closeBtn.onclick = async () => { 
                        encounterModal.style.display = 'none'; 
                        await handleShadowSpawnsAndTurns();
                    };
                }
                encounterActionBtns.appendChild(closeBtn);
            }
        }, 100);
    };

    const battleBtn = document.createElement('button');
    battleBtn.textContent = 'Vai in battaglia';
    battleBtn.onclick = () => { encounterModal.style.display = 'none'; startBattle(enemy); };
    encounterActionBtns.appendChild(rollBtn);
    encounterActionBtns.appendChild(battleBtn);
  }
  
  function handleGameOver(source) {
      const prisonerMessage = getPrisonerStatusMessage();
      battleResult.innerHTML = `GAME OVER.<br>Sei stato sconfitto ${source}.<br>Nemici uccisi: ${enemiesDefeatedCount}<br>${prisonerMessage}`;
      battleResult.style.color = 'red';
      battleResult.style.fontSize = '22px';
      battleActionContainer.innerHTML = '';
      diceBtn.disabled = true;
      const newGameButton = document.createElement('button');
      newGameButton.textContent = "Inizia una nuova partita";
      newGameButton.onclick = () => { 
        battleModal.style.display = 'none';
        setBattleMode(false);
        promptForNewGame(); 
      };
      battleActionContainer.appendChild(newGameButton);
  }

  function attemptEscape() {
      battleActionContainer.innerHTML = '';
      battleResult.innerHTML = 'Tenti la fuga...';
      battleResult.style.color = '#ffcc00';
      battleResult.style.fontSize = '18px';
      let flips = 10;
      const timer = setInterval(() => {
          battlePlayerDice.textContent = Math.floor(Math.random() * 6) + 1;
          if (--flips <= 0) {
              clearInterval(timer);
              const damageRoll = Number(battlePlayerDice.textContent);
              character.hp -= (damageRoll + 1);
              updatePlayerInfo();
              if (character.hp <= 0) { window.updateBattleUI(); handleGameOver("durante la fuga"); } 
              else {
                  setMainMessage(`Fuga riuscita! Ma perdi ${damageRoll + 1} PF.`, '#ffcc00');
                  battleModal.style.display = 'none';
                  setBattleMode(false);
                  handleShadowSpawnsAndTurns();
              }
          }
      }, 100);
  }

  function startBattle(enemy) {
    diceBtn.disabled = true;
    setBattleMode(true);
    if (!character) return;
    
    if (!enemy.isShadow) {
        if (enemy.isBoss) { enemy.startHP = 15; enemy.attackDie = 8; enemy.attackBonus = 1; } 
        else {
            if (enemiesDefeatedCount < 3) { enemy.startHP = 10; enemy.attackDie = 6; enemy.attackBonus = 0; } 
            else if (enemiesDefeatedCount < 6) { enemy.startHP = 12; enemy.attackDie = 6; enemy.attackBonus = 0; } 
            else if (enemiesDefeatedCount < 9) { enemy.startHP = 12; enemy.attackDie = 8; enemy.attackBonus = 0; } 
            else { enemy.startHP = 15; enemy.attackDie = 8; enemy.attackBonus = 0; }
        }
    }
    
    const cellInfo = visitedCells.get(currentCell.dataset.cellNumber);
    let currentEnemyHP = enemy.isShadow ? enemy.hp : (cellInfo && cellInfo.hp > 0 ? cellInfo.hp : enemy.startHP);
    if (cellInfo && !enemy.isShadow) cellInfo.hp = currentEnemyHP;
    if (cellInfo && !enemy.isBoss && !enemy.isShadow) { cellInfo.enemy.name = `Orchetto ${enemiesDefeatedCount + 1}`; }
    
    battlePlayerName.textContent = character.name;
    battleEnemyName.textContent = enemy.name;

    const playerAttackBonus = getAttackBonus();
    const playerAttackDie = character.hasSpecialSword ? 8 : 6;
    const swordBonus = character.hasSpecialSword ? 1 : 0;
    let totalBonus = playerAttackBonus + swordBonus;
    
    battlePlayerAttack.textContent = `Attacco: 1D${playerAttackDie}${totalBonus > 0 ? ' + ' + totalBonus : totalBonus < 0 ? ' ' + totalBonus : ''}`;
    battleEnemyAttack.textContent = `Attacco: 1D${enemy.attackDie}${(enemy.attackBonus || 0) > 0 ? ' + ' + enemy.attackBonus : ''}`;

    window.updateBattleUI = function() {
        battlePlayerPF.textContent = `PF: ${character.hp > 0 ? character.hp : 0} / ${maxHP}`;
        battleEnemyPF.textContent = `PF: ${currentEnemyHP > 0 ? currentEnemyHP : 0} / ${enemy.startHP}`;
    }

    updateBattleUI();
    battleModal.style.display = 'block';
    battlePlayerDice.textContent = '-'; battleEnemy
