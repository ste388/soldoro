<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soldoro - Dungeon 72 Celle</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
  <style>
    body { 
      background-image: url('https://ste388.github.io/soldoro/img/sfondo.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-attachment: fixed;
      color:#e6e6e6; 
      font-family:Arial, sans-serif; 
      display:flex;
      justify-content: center;
      gap:20px; 
      padding:20px;
      padding-top: 100px;
      align-items: flex-start;
      box-sizing: border-box;
    }
    
    @keyframes screenShake {
      0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); }
    }
    
    @keyframes splatOnScreen {
      0% { transform: scale(0.3) rotate(-15deg); opacity: 0; }
      70% { transform: scale(1.1) rotate(5deg); opacity: 0.8; }
      100% { transform: scale(1) rotate(0deg); opacity: 0.8; }
    }

    .shake { animation: screenShake 0.5s; }

    #sticky-controls {
      position: fixed; top: 0; left: 0; width: 100%; background: #1a1915; border-radius: 0 0 10px 10px; z-index: 1000; padding: 10px; display: flex; gap: 14px; justify-content: center; align-items: center; box-shadow: 0 2px 12px rgba(0,0,0,0.40); transition: top 0.3s ease-in-out;
    }
    
    #left, #right { width:240px; display:flex; flex-direction:column; gap:10px; }
    #center-column { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 520px; }
    #board-wrapper { width: 100%; overflow-x: auto; -webkit-overflow-scrolling: touch; }
    #center { display: grid; grid-template-columns: repeat(9, 50px); gap: 4px; width: fit-content; background: rgba(20, 19, 15, 0.7); border-radius:10px; padding: 10px; box-shadow:inset 0 0 12px #000; }
    #right { align-items:center; }
    button { padding:10px 16px; border:none; border-radius:8px; background:#5a8c56; color:#fff; cursor:pointer; font-size:16px; width:100%; box-sizing: border-box; }
    #left button { min-width: 150px; }
    button:hover { background:#7cb673; }
    button:disabled { background:#555; cursor:not-allowed; }
    #sticky-controls button { width: auto; min-width: 120px; margin: 0; }
    #tradeBtn { background-color: #3b6b8c; }
    #tradeBtn:hover { background-color: #5a8ab0; }
    .intervention-btn { background-color: #c4832c; }
    .intervention-btn:hover { background-color: #e6a243; }
    .ignore-btn { background-color: #757575; }
    .ignore-btn:hover { background-color: #9e9e9e; }
    
    .cell { position: relative; width: 50px; height: 50px; border:2px solid #666; border-radius:6px; background:linear-gradient(145deg, rgba(74, 73, 63, 0.7), rgba(55, 55, 40, 0.7)); user-select:none; box-sizing: border-box; }
    .cell-content { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-weight: bold; color: #bfc5a7; }
    .visited { background: linear-gradient(145deg, #304d30, #223822); border-color: #658665; }
    .current-player-1 { background: linear-gradient(145deg, rgba(143, 173, 106, 0.8), rgba(110, 133, 71, 0.8)); border-color: #a0d535; color: #eff7d6; box-shadow: 0 0 10px #a0d535; }
    .current-player-2 { background: linear-gradient(145deg, rgba(106, 143, 173, 0.8), rgba(71, 110, 133, 0.8)); border-color: #35a0d5; color: #d6eaff; box-shadow: 0 0 10px #35a0d5; }
    .highlighted { border: 3px solid white !important; cursor: pointer; }
    
    .enemy-marker, .gas-marker { position:absolute; width:10px; height:10px; border-radius:50%; border:1px solid #fff; }
    .enemy-marker { top:3px; right:3px; background:red; }
    .gas-marker { bottom:3px; left:3px; background:#808080;}
    .hole-marker { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width: 40px; height: 40px; border-radius: 0; border: none; background-image: url('https://ste388.github.io/soldoro/img/buco.png'); background-size: contain; background-repeat: no-repeat; background-position: center; }

    .skull-marker, .prisoner-marker, .shadow-marker, .hero-marker, .item-marker { position:absolute; top:50%; left:50%; transform: translate(-50%, -50%); width: 80%; height: 80%; pointer-events:none; opacity: 0.9; }
    .item-marker { width: 70%; height: 70%; z-index: 6; }
    .skull-marker, .prisoner-marker { z-index: 5; }
    .hero-marker, .shadow-marker { z-index: 10; }
    .gem-door-marker { border: 3px solid deepskyblue !important; box-shadow: 0 0 15px deepskyblue; }
    .purification-altar-border { border: 3px solid yellow !important; box-shadow: 0 0 15px yellow; }

    #diceResult, #shadowDiceResult { width:80px; height:80px; font-size:48px; font-weight:bold; display:flex; align-items:center; justify-content:center; border:2px solid #a0d535; border-radius:10px; background:linear-gradient(145deg,#6e8547,#8fad6a); color:#d7f39b; }
    #shadowDiceResult { border-color: #993333; background: linear-gradient(145deg, #6b2a2a, #8f4b4b); color: #f3c2c2;}
    #main-message-display { min-height:24px; font-weight:bold; text-align:center; background-color: rgba(0,0,0,0.4); border-radius: 5px; padding: 5px; width:100%; box-sizing: border-box; visibility: hidden; }
    #shadowActionDisplay { display:none; min-height:24px; text-align:center; background-color: rgba(0,0,0,0.4); border-radius: 5px; padding: 5px; width:100%; box-sizing: border-box; margin-top: 10px; }
    
    #discoveriesLog { white-space: pre-line; background:rgba(58, 58, 43, 0.8); border-radius:8px; padding:10px; font-size:14px; min-height: 200px; width: 100%;}
    #playerInfo { text-align:center; padding: 5px 10px; border-radius:10px; min-width: 180px; font-weight: bold; }
    .player-1-info { border: 2px solid #a0d535; background: linear-gradient(145deg, #6e8547, #8fad6a); color: #eff7d6; }
    .player-2-info { border: 2px solid #35a0d5; background: linear-gradient(145deg, #476e85, #6a8fad); color: #d6eaff; }

    #playerCountModal, #charForm, #encounterModal, #messageModal, #initiativeModal, #potionDamageModal, #battlePotionSelectModal, #altarModal, #allyChoiceModal, #supportAttackModal, #tradeModal, #fountainModal { display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background: #3a3a2b; padding:20px; border-radius:10px; box-shadow:0 0 15px #000; z-index:1001; text-align:center; width: 300px; }
    #charForm input, #charForm select, #playerCountModal select { width: calc(100% - 16px); padding:8px; margin:8px 0; border:none; border-radius:6px; font-size:16px; }
    
    #battleModal { display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background: #3a3a2b; padding:20px; border-radius:10px; box-shadow:0 0 15px #000; z-index:1050; text-align:center; width: 900px; max-width: 95%; flex-direction: column; max-height: 90vh; overflow-y: auto; }
    #initiativeModal { z-index: 1051; }
    #potionDamageModal, #battlePotionSelectModal { z-index: 1060; }
    #altarModal { z-index: 1070; }
    #allyChoiceModal { z-index: 1080; }
    #supportAttackModal { z-index: 1090; }
    #tradeModal { z-index: 1100; width: 90%; max-width: 800px; display: flex; flex-direction: column; max-height: 80vh; overflow-y: auto; }
    #altarActions, #allyChoiceActions, #supportAttackActions, #fountainActions { display: flex; gap: 10px; justify-content: center; margin-top: 15px; }

    #tradeContainer { display: flex; gap: 20px; text-align: left; flex-grow: 1; min-height: 0; }
    .trade-column { flex: 1; display: flex; flex-direction: column; min-height: 0; }
    .trade-column h3 { text-align: center; }
    .inventory-list { list-style: none; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; flex-grow: 1; overflow-y: auto; }
    .inventory-list li { padding: 8px; margin-bottom: 5px; background: #4f4f3e; border-radius: 5px; cursor: pointer; border: 2px solid transparent; }
    .inventory-list li:hover { background: #6a6a52; }
    .inventory-list li.selected { border-color: #ffeb3b; background: #7c7c5e; }
    #trade-actions { display: flex; flex-direction: column; justify-content: center; gap: 15px; }


    #combatants-container { display: flex; justify-content: space-between; gap: 15px; }
    #player-side, #enemy-side { flex: 1; display: flex; flex-direction: column; gap: 10px; }
    .battle-unit { margin: 0; border: 1px solid #555; padding: 10px; border-radius: 8px; transition: box-shadow 0.3s, border-color 0.3s; }
    .battle-unit.highlight-winner { box-shadow: 0 0 15px 3px #ffeb3b; border-color: #ffeb3b; }
    .battle-name { font-weight: bold; font-size: 20px; margin-bottom: 5px; color: #a0d535; }
    #allyJoinedIndicator { font-size: 14px; color: #fdd835; font-weight: bold; display:none; text-align: center; margin: 5px 0; }
    .battle-stats { font-size: 14px; color: #ccc; }
    .battle-pf, .battle-attack, .battle-defense { font-size: 16px; margin-bottom: 5px; }
    .battle-dice { font-size: 48px; font-weight: bold; min-height: 60px; display:flex; align-items:center; justify-content:center; }
    #battleResult { font-size: 18px; font-weight: bold; min-height: 24px; margin-top: 10px; transition: font-size 0.2s; line-height: 1.2; }
    #battleActionContainer, #initiativeActionContainer { display:flex; flex-direction:column; gap:10px; margin-top: 15px; }
    #specialAbilitiesContainer { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; justify-content: center;}
    #specialAbilitiesContainer button { font-size: 12px; padding: 8px 12px; flex-basis: calc(50% - 4px); }
    #initiativeResult { font-weight: bold; font-size: 18px; min-height: 24px; }
    #battleLog { display: none; }
    
    #battlePotionSelectModal button { background-color: #3b6b8c; margin-bottom: 5px;}
    #battlePotionSelectModal button:hover { background-color: #5a8ab0; }

    #itemFoundModal {
        display: none; position: fixed; z-index: 2000; left: 50%; top: 50%; transform: translate(-50%, -50%);
        background-color: rgba(0,0,0,0.85); padding: 25px; border-radius: 15px; text-align: center;
        color: white; border: 3px solid #ffeb3b; box-shadow: 0 0 25px #ffeb3b;
    }
    #itemFoundModal.overlay-effect { 
      top: 0; left: 0; width: 100%; height: 100%;
      transform: none;
      display: flex; justify-content: center; align-items: center;
      background-color: transparent; border: none; box-shadow: none; padding: 0; pointer-events: none;
    }
    #itemFoundModal.overlay-effect img {
        width: auto; height: auto; max-width: 90%; max-height: 90%;
        object-fit: contain; opacity: 0.8;
    }
    #itemFoundModal.overlay-effect img.splat-effect {
        animation: splatOnScreen 0.4s ease-out forwards;
    }
    #itemFoundModal img { width: 100px; height: 100px; }
    #itemFoundModal p { margin: 0; font-family: 'MedievalSharp', cursive; }
    #itemFoundTitle { font-size: 24px; font-weight: bold; margin-bottom: 15px; color: #ffeb3b; }
    #itemFoundName { font-size: 20px; font-weight: bold; margin-top: 12px; }
    #itemFoundExtraText { font-size: 16px; color: #d2b48c; margin-top: 15px; font-style: italic; max-width: 280px; line-height: 1.4; }
    #itemFoundCloseBtn { margin-top: 20px; padding: 8px 25px; background-color: #8b5e3c; border-radius: 5px; border: 2px solid #5a3d2e; font-family: 'MedievalSharp', cursive; font-size: 18px; }
    #itemFoundCloseBtn:hover { background-color: #a3764a; }


    #messageModal { background: linear-gradient(135deg, #4a3c26, #2d1f0f); border: 4px solid #8b5e3c; color: #f5deb3; font-family: 'MedievalSharp', cursive; font-size: 22px; }
    #messageModal.victory-modal .modal-content { display: flex; flex-direction: column; align-items: center; }
    #messageModal.victory-modal #messageModalText { font-size: 28px; margin-bottom: 5px; white-space: pre-line; }
    #messageModal.victory-modal #victorySubText { font-size: 18px; margin-bottom: 10px; white-space: pre-line; }
    #messageModal.victory-modal #prisonerStatusText { font-size: 16px; color: #d2b48c; }
    #messageModal button { font-family: 'MedievalSharp', cursive; font-size: 18px; margin-top: 20px; padding: 8px 25px; background-color: #8b5e3c; border-radius: 5px; border: 2px solid #5a3d2e; }
    #messageModal button:hover { background-color: #a3764a; }
    
    #encounterModal {
        border: 4px solid red;
        box-shadow: 0 0 25px red;
    }


    @media (max-width: 1024px) {
      body { flex-direction: column; padding: 10px; padding-top: 160px; gap: 10px; align-items: stretch; }
      #right { order: 1; align-items: stretch; }
      #center-column { order: 2; width: 100%; align-items: stretch; }
      #left { order: 3; }
      #left, #right { width: 100%; box-sizing: border-box; }
      #charForm, #encounterModal, #messageModal, #initiativeModal, #potionDamageModal, #battlePotionSelectModal, #altarModal, #allyChoiceModal, #supportAttackModal, #playerCountModal, #fountainModal { width: 90%; }
      #tradeModal { flex-direction: column; }
      #tradeContainer { flex-direction: column; }
      #trade-actions { flex-direction: row; margin-top: 10px; }

      #battleModal { padding: 10px; }
      #combatants-container { flex-direction: column; }
      .battle-name { font-size: 18px; }
      .battle-pf, .battle-attack, .battle-defense { font-size: 14px; }
      .battle-dice { font-size: 40px; min-height: 50px; }
      
      #sticky-controls { flex-wrap: wrap; justify-content: space-around; }
      #sticky-controls button { flex-basis: 45%; min-width: auto; }
      #diceResult, #shadowDiceResult { flex-basis: 45%; }
      #playerInfo { flex-basis: 100%; margin-top: 5px; }
    }
  </style>
</head>
<body>

  <div id="sticky-controls">
      <div id="player-actions">
        <button id="diceRollBtn">Tira dado</button>
      </div>
      <div id="diceResult">-</div>
      <div id="playerInfo">Crea un personaggio</div>
      <div id="energyInfo" style="color: #4dd0e1; font-weight: bold;">Energia: <span id="energyValue">0</span></div>
  </div>

  <div id="left">
    <button id="saveGameBtn">Salva</button>
    <button id="loadGameBtn" style="display:none;">Carica Partita</button>
    <button id="newGameBtn">Nuova Partita</button>
  </div>
  
  <div id="center-column">
    <div id="main-message-display"></div>
    <div id="board-wrapper">
        <div id="center"></div>
    </div>
    <div id="discoveriesLog"></div>
  </div>

  <div id="right">
    <div id="shadowActionDisplay">
        <div id="shadowTurnName">Turno Ombre</div>
        <div id="shadowDiceResult">-</div>
    </div>
  </div>
  
  <div id="playerCountModal">
      <h2>Numero di giocatori</h2>
      <select id="playerCountSelect">
          <option value="1" selected>1 Giocatore</option>
          <option value="2">2 Giocatori</option>
      </select>
      <button id="playerCountConfirmBtn" style="margin-top:20px;">Conferma</button>
  </div>

  <div id="charForm">
    <div id="charFormTitle">Crea Personaggio</div>
    <div>Nome personaggio</div>
    <input type="text" id="charName" placeholder="Nome...">
    <div>PF iniziali</div>
    <input type="number" id="charHP" value="35" min="1">
    <div>Classe</div>
    <select id="charClass">
      <option value="Guerriero">Guerriero (+10 PF, +5 Energia)</option>
      <option value="Esploratore">Esploratore (-1 buchi, -2 rampicanti, rilancio)</option>
      <option value="Ladro">Ladro (Furtività e Fuga Migliorate)</option>
    </select>
    <div style="display:flex; gap:8px; margin-top:10px;">
      <button id="startAdventureBtn">Inizia Avventura</button>
      <button id="cancelCharBtn">Annulla</button>
    </div>
  </div>
  
  <div id="encounterModal">
    <div id="encounterContent">
        <p id="encounterMessage"></p>
        <div id="encounterModal-diceResult"></div>
    </div>
    <div id="encounterActionBtns"></div>
  </div>

  <div id="initiativeModal">
    <p id="initiativeMessage"></p>
    <div class="battle-unit">
        <div id="initiativePlayerName" class="battle-name"></div>
        <div id="initiativePlayerStats" class="battle-stats"></div>
        <div id="initiativePlayerDice" class="battle-dice">-</div>
    </div>
    <div class="battle-unit">
        <div id="initiativeEnemyName" class="battle-name"></div>
        <div id="initiativeEnemyStats" class="battle-stats"></div>
        <div id="initiativeEnemyDice" class="battle-dice">-</div>
    </div>
    <p id="initiativeResult"></p>
    <div id="initiativeActionContainer">
        <button id="initiativeRollBtn">Lancia i dadi</button>
        <button id="usePotionInitiativeBtn">Usa Pozione</button>
    </div>
  </div>

 <div id="battleModal">
    <div id="combatants-container">
        <div id="player-side">
            <div class="battle-unit" id="main-player-battle-unit">
                <div id="battlePlayerName" class="battle-name"></div>
                <div id="battlePlayerPF" class="battle-pf"></div>
                <div id="battlePlayerAttack" class="battle-attack"></div>
                <div id="battlePlayerDefense" class="battle-defense"></div>
                <div id="battlePlayerDice" class="battle-dice">-</div>
            </div>
             <div class="battle-unit" id="ally-battle-unit" style="display:none;">
                <div id="battleAllyName" class="battle-name"></div>
                <div id="battleAllyPF" class="battle-pf"></div>
                <div id="battleAllyAttack" class="battle-attack"></div>
                <div id="battleAllyDefense" class="battle-defense"></div>
                 <div id="battleAllyDice" class="battle-dice">-</div>
            </div>
        </div>
        <div id="enemy-side">
            <div class="battle-unit">
                <div id="battleEnemyName" class="battle-name"></div>
                <div id="battleEnemyPF" class="battle-pf"></div>
                <div id="battleEnemyAttack" class="battle-attack"></div>
                <div id="battleEnemyDefense" class="battle-defense"></div>
                <div id="battleEnemyDice" class="battle-dice">-</div>
            </div>
        </div>
    </div>
    <div id="allyJoinedIndicator">Alleato in combattimento!</div>
    <div id="battleLog"></div>
    <div id="battleResult"></div>
    <div id="battleActionContainer"></div>
    <div id="specialAbilitiesContainer"></div>
  </div>

  <div id="messageModal">
      <div class="modal-content">
          <div id="messageModalText"></div>
          <div id="victorySubText"></div>
          <div id="prisonerStatusText"></div>
      </div>
      <button id="messageModalOkBtn">OK</button>
  </div>
  
  <div id="fountainModal">
    <p id="fountainMessage"></p>
    <div id="fountainActions"></div>
  </div>

  <div id="altarModal">
    <p id="altarMessage"></p>
    <div id="altarActions"></div>
  </div>
  
  <div id="allyChoiceModal">
    <p id="allyChoiceMessage"></p>
    <div id="allyChoiceActions"></div>
  </div>
  
  <div id="supportAttackModal">
      <p id="supportAttackMessage"></p>
      <div id="supportAttackDice" class="battle-dice">-</div>
      <div id="supportAttackActions"></div>
  </div>

  <div id="tradeModal">
    <h2>Scambio Oggetti</h2>
    <div id="tradeContainer">
      <div class="trade-column">
        <h3 id="tradePlayer1Name"></h3>
        <ul id="player1InventoryList" class="inventory-list"></ul>
      </div>
      <div id="trade-actions">
        <button id="toPlayer2Btn" disabled>&raquo;</button>
        <button id="toPlayer1Btn" disabled>&laquo;</button>
      </div>
      <div class="trade-column">
        <h3 id="tradePlayer2Name"></h3>
        <ul id="player2InventoryList" class="inventory-list"></ul>
      </div>
    </div>
    <button id="closeTradeBtn" style="margin-top: 20px;">Chiudi</button>
  </div>

  <div id="battlePotionSelectModal">
    <p>Seleziona una pozione da usare</p>
    <div id="battlePotionList"></div>
    <button id="closeBattlePotionSelectBtn" style="margin-top:15px;">Annulla</button>
  </div>

  <div id="potionDamageModal">
      <p id="potionDamageTitle"></p>
      <div id="potionDamageDice" style="font-size: 48px; font-weight: bold; min-height: 60px;">-</div>
      <button id="potionDamageRollBtn">Lancia</button>
  </div>

  <div id="itemFoundModal">
      <p id="itemFoundTitle"></p>
      <img id="itemFoundImg" src="" alt="Oggetto Trovato">
      <p id="itemFoundName"></p>
      <p id="itemFoundExtraText"></p>
      <button id="itemFoundCloseBtn">Chiudi</button>
  </div>


<script>
  // --- Gestione Suoni ---
  const sounds = {
    dice: new Audio('https://ste388.github.io/soldoro/fx/dadi.mp3'),
    hit: new Audio('https://ste388.github.io/soldoro/fx/colpoSpada.mp3'),
    powerhit: new Audio('https://ste388.github.io/soldoro/fx/colpo.mp3'),
    item: new Audio('https://ste388.github.io/soldoro/fx/trovare.mp3'),
    step: new Audio('https://ste388.github.io/soldoro/fx/passi.mp3'),
    shadow: new Audio('https://ste388.github.io/soldoro/fx/AppareOmbra.mp3'),
    battle: new Audio('https://ste388.github.io/soldoro/fx/battaglia.mp3'),
    parry: new Audio('https://ste388.github.io/soldoro/fx/parata.mp3'),
    background: new Audio('https://ste388.github.io/soldoro/fx/Sottofondo.mp3'),
    death: new Audio('https://ste388.github.io/soldoro/fx/morte.mp3'),
    death2: new Audio('https://ste388.github.io/soldoro/fx/morte2.mp3'),
    deathShadow: new Audio('https://ste388.github.io/soldoro/fx/MorteOmbra.mp3'),
    removeCurse: new Audio('https://ste388.github.io/soldoro/fx/RimuoviMaledizione.mp3'),
    curse: new Audio('https://ste388.github.io/soldoro/fx/maledizione.mp3'),
    hole: new Audio('https://ste388.github.io/soldoro/fx/buco.mp3'),
    gas: new Audio('https://ste388.github.io/soldoro/fx/gas.mp3'),
    vines: new Audio('https://ste388.github.io/soldoro/fx/rampicante.mp3'),
    prisoner: new Audio('https://ste388.github.io/soldoro/fx/prigioniero.mp3'),
    fountain: new Audio('https://ste388.github.io/soldoro/fx/fontana.mp3'),
    drink: new Audio('https://ste388.github.io/soldoro/fx/bere.mp3'),
    throw: new Audio('https://ste388.github.io/soldoro/fx/lancio.mp3'),
    bossAppear: new Audio('https://ste388.github.io/soldoro/fx/TrovoBossfinale.mp3'),
    bossDeath: new Audio('https://ste388.github.io/soldoro/fx/morteBossFinale.mp3'),
    gameLost: new Audio('https://ste388.github.io/soldoro/fx/gameLost.mp3'),
    gameWin: new Audio('https://ste388.github.io/soldoro/fx/gameWin.mp3'),
    trovoOrchetto: [
      new Audio('https://ste388.github.io/soldoro/fx/trovoOrchetto.mp3'),
      new Audio('https://ste388.github.io/soldoro/fx/trovoOrchetto1.mp3'),
    ],
    trovoOrco: [
      new Audio('https://ste388.github.io/soldoro/fx/trovoOrco1.mp3'),
      new Audio('https://ste388.github.io/soldoro/fx/trovoOrco2.mp3'),
    ],
    trovoTroll: [
      new Audio('https://ste388.github.io/soldoro/fx/trovoTroll1.mp3'),
      new Audio('https://ste388.github.io/soldoro/fx/trovoTroll2.mp3'),
    ]
  };

  sounds.battle.loop = true;
  sounds.battle.volume = 0.3;
  sounds.background.loop = true;
  sounds.background.volume = 0.6;
  
  let deathSoundToggle = false;
  let audioInitialized = false;

  function initAudio() {
    if (audioInitialized) return;
    const allSounds = Object.values(sounds).flat();
    const promises = allSounds.map(sound => sound.play().catch(e => { /* ignore */ }));
    
    Promise.all(promises).then(() => {
        allSounds.forEach(sound => {
            sound.pause();
            sound.currentTime = 0;
        });
        audioInitialized = true;
        playSound('background');
        console.log("Audio context unlocked and sounds ready.");
    }).catch(error => {
        console.warn("Could not unlock audio context automatically.", error);
        audioInitialized = true;
        playSound('background');
    });
    
    window.removeEventListener('click', initAudio);
    window.removeEventListener('touchstart', initAudio);
  }

  function playSound(soundName) {
    if (!audioInitialized) return;
    const sound = sounds[soundName];
    if (Array.isArray(sound)) {
      const randomIndex = Math.floor(Math.random() * sound.length);
      const randomSound = sound[randomIndex];
      playSoundObject(randomSound);
    } else if (sound) {
      playSoundObject(sound);
    }
  }

  function playSoundObject(sound) {
    setTimeout(() => {
        if (!sound.loop) {
            sound.currentTime = 0;
        }
        const playPromise = sound.play();
        if (playPromise !== undefined) {
            playPromise.catch(error => console.warn(`Sound playback failed: ${error.name}`));
        }
    }, 100);
  }

  function stopSound(soundName) {
      if (!audioInitialized) return;
      const sound = sounds[soundName];
      if (sound) {
        sound.pause();
        sound.currentTime = 0;
      }
  }

  // Elementi DOM
  const board = document.getElementById('center');
  const discoveriesLog = document.getElementById('discoveriesLog');
  const playerActions = document.getElementById('player-actions');
  const diceRes = document.getElementById('diceResult');
  const shadowActionDisplay = document.getElementById('shadowActionDisplay');
  const shadowTurnName = document.getElementById('shadowTurnName');
  const shadowDiceRes = document.getElementById('shadowDiceResult');
  const mainMessageDisplay = document.getElementById('main-message-display');
  const playerInfo = document.getElementById('playerInfo');
  const energyValue = document.getElementById('energyValue');
  const newGameBtn = document.getElementById('newGameBtn');
  const saveGameBtn = document.getElementById('saveGameBtn');
  const loadGameBtn = document.getElementById('loadGameBtn');
  const playerCountModal = document.getElementById('playerCountModal');
  const charForm = document.getElementById('charForm');
  const charFormTitle = document.getElementById('charFormTitle');
  const startAdventureBtn = document.getElementById('startAdventureBtn');
  const cancelCharBtn = document.getElementById('cancelCharBtn');
  const encounterModal = document.getElementById('encounterModal');
  const encounterContent = document.getElementById('encounterContent');
  const encounterMessage = document.getElementById('encounterMessage');
  const encounterDiceResult = document.getElementById('encounterModal-diceResult');
  const encounterActionBtns = document.getElementById('encounterActionBtns');
  const battleModal = document.getElementById('battleModal');
  const battlePlayerName = document.getElementById('battlePlayerName');
  const allyJoinedIndicator = document.getElementById('allyJoinedIndicator');
  const battlePlayerPF = document.getElementById('battlePlayerPF');
  const battlePlayerAttack = document.getElementById('battlePlayerAttack');
  const battlePlayerDefense = document.getElementById('battlePlayerDefense');
  const battlePlayerDice = document.getElementById('battlePlayerDice');
  const allyBattleUnit = document.getElementById('ally-battle-unit');
  const battleAllyName = document.getElementById('battleAllyName');
  const battleAllyPF = document.getElementById('battleAllyPF');
  const battleAllyAttack = document.getElementById('battleAllyAttack');
  const battleAllyDefense = document.getElementById('battleAllyDefense');
  const battleAllyDice = document.getElementById('battleAllyDice');
  const battleEnemyName = document.getElementById('battleEnemyName');
  const battleEnemyPF = document.getElementById('battleEnemyPF');
  const battleEnemyAttack = document.getElementById('battleEnemyAttack');
  const battleEnemyDefense = document.getElementById('battleEnemyDefense');
  const battleEnemyDice = document.getElementById('battleEnemyDice');
  const battleResult = document.getElementById('battleResult');
  const battleLog = document.getElementById('battleLog');
  const battleActionContainer = document.getElementById('battleActionContainer');
  const specialAbilitiesContainer = document.getElementById('specialAbilitiesContainer');
  const messageModal = document.getElementById('messageModal');
  const messageModalText = document.getElementById('messageModalText');
  const victorySubText = document.getElementById('victorySubText');
  const prisonerStatusText = document.getElementById('prisonerStatusText');
  const messageModalOkBtn = document.getElementById('messageModalOkBtn');
  const stickyControls = document.getElementById('sticky-controls');
  const initiativeModal = document.getElementById('initiativeModal');
  const initiativeMessage = document.getElementById('initiativeMessage');
  const initiativePlayerName = document.getElementById('initiativePlayerName');
  const initiativePlayerStats = document.getElementById('initiativePlayerStats');
  const initiativePlayerDice = document.getElementById('initiativePlayerDice');
  const initiativeEnemyName = document.getElementById('initiativeEnemyName');
  const initiativeEnemyStats = document.getElementById('initiativeEnemyStats');
  const initiativeEnemyDice = document.getElementById('initiativeEnemyDice');
  const initiativeResult = document.getElementById('initiativeResult');
  const initiativeRollBtn = document.getElementById('initiativeRollBtn');
  const usePotionInitiativeBtn = document.getElementById('usePotionInitiativeBtn');
  const battlePotionSelectModal = document.getElementById('battlePotionSelectModal');
  const battlePotionList = document.getElementById('battlePotionList');
  const closeBattlePotionSelectBtn = document.getElementById('closeBattlePotionSelectBtn');
  const potionDamageModal = document.getElementById('potionDamageModal');
  const potionDamageTitle = document.getElementById('potionDamageTitle');
  const potionDamageDice = document.getElementById('potionDamageDice');
  const potionDamageRollBtn = document.getElementById('potionDamageRollBtn');
  const altarModal = document.getElementById('altarModal');
  const altarMessage = document.getElementById('altarMessage');
  const altarActions = document.getElementById('altarActions');
  const fountainModal = document.getElementById('fountainModal');
  const fountainMessage = document.getElementById('fountainMessage');
  const fountainActions = document.getElementById('fountainActions');
  const allyChoiceModal = document.getElementById('allyChoiceModal');
  const allyChoiceMessage = document.getElementById('allyChoiceMessage');
  const allyChoiceActions = document.getElementById('allyChoiceActions');
  const supportAttackModal = document.getElementById('supportAttackModal');
  const supportAttackMessage = document.getElementById('supportAttackMessage');
  const supportAttackDice = document.getElementById('supportAttackDice');
  const supportAttackActions = document.getElementById('supportAttackActions');
  const tradeModal = document.getElementById('tradeModal');
  const player1InventoryList = document.getElementById('player1InventoryList');
  const player2InventoryList = document.getElementById('player2InventoryList');
  const toPlayer1Btn = document.getElementById('toPlayer1Btn');
  const toPlayer2Btn = document.getElementById('toPlayer2Btn');
  const closeTradeBtn = document.getElementById('closeTradeBtn');
  
  // Costanti di Gioco
  const COLS = 9, CELL_COUNT = 72, ENEMY_COUNT = 12, PRISONER_COUNT = 11, GAS_TRAP_COUNT = 2, HOLE_COUNT = 3, GAS_EFFECT_DURATION_CELLS = 5;
  const HOLE_IMAGE_URL = 'https://ste388.github.io/soldoro/img/buco.png';
  const ATTACK_BONUS_ITEMS = [ { name: "Elsa migliorata", iconUrl: "https://ste388.github.io/soldoro/img/elsa.png" }, { name: "Guanti rinforzati", iconUrl: "https://ste388.github.io/soldoro/img/guanti.png" }, { name: "Stivali", iconUrl: "https://ste388.github.io/soldoro/img/stivali.png" } ];
  const DEFENSE_BONUS_ITEMS = [ { name: "Scudo di ferro", iconUrl: "https://ste388.github.io/soldoro/img/scudo.png" }, { name: "Elmo", iconUrl: "https://ste388.github.io/soldoro/img/elmo.png" }, { name: "Corazza", iconUrl: "https://ste388.github.io/soldoro/img/corazza.png" } ];
  const POTIONS = [ { name: "Pozione Fuoco", type: "fire", iconUrl: "https://ste388.github.io/soldoro/img/pozioneFuoco.png" }, { name: "Pozione Fuoco", type: "fire", iconUrl: "https://ste388.github.io/soldoro/img/pozioneFuoco.png" }, { name: "Pozione Ghiaccio", type: "ice", iconUrl: "https://ste388.github.io/soldoro/img/pozioneGhiaccio.png" }, { name: "Pozione Ghiaccio", type: "ice", iconUrl: "https://ste388.github.io/soldoro/img/pozioneGhiaccio.png" }, { name: "Pozione (+5 PF)", value: 5, type: "heal", iconUrl: "https://ste388.github.io/soldoro/img/pozione.png" }, { name: "Pozione (+10 PF)", value: 10, type: "heal", iconUrl: "https://ste388.github.io/soldoro/img/pozione.png" }, { name: "Pozione (+15 PF)", value: 15, type: "heal", iconUrl: "https://ste388.github.io/soldoro/img/pozione.png" } ];
  const GEMS = [ { name: "Gemma Blu", iconUrl: "https://ste388.github.io/soldoro/img/gemmaBlu.png" }, { name: "Gemma Verde", iconUrl: "https://ste388.github.io/soldoro/img/gemmaVerde.png" }, { name: "Gemma Viola", iconUrl: "https://ste388.github.io/soldoro/img/gemmaViola.png" } ];
  const GEM_DOOR = { name: "Porta di Gemme", iconUrl: "https://ste388.github.io/soldoro/img/portaGemme.png" };
  const ALTARS = [ { name: "Altare Sacrificale", type: 'sacrificial', iconUrl: "https://ste388.github.io/soldoro/img/altareSacrificale.png" }, { name: "Altare della Maledizione", type: 'curse', iconUrl: "https://ste388.github.io/soldoro/img/AltareMaledizione.png" }, { name: "Altare della Purificazione", type: 'purification', iconUrl: "https://ste388.github.io/soldoro/img/AltarePurificazione.png" } ];
  const HEALING_FOUNTAIN = { name: "Fontana Curativa", iconUrl: "https://ste388.github.io/soldoro/img/fontana.png" };
  const SHADOW_SPAWNS = [ { name: "Ombra", hp: 10, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 1, iconUrl: "https://ste388.github.io/soldoro/img/ombra.png", spawnTurn: 10 }, { name: "Ombra Paurosa", hp: 15, attackDie: 10, attackBonus: 1, defenseDie: 8, defenseBonus: 0, iconUrl: "https://ste388.github.io/soldoro/img/OmbraPaurosa.png", spawnTurn: 30 }, { name: "Ombra Cattiva", hp: 20, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 1, iconUrl: "https://ste388.github.io/soldoro/img/OmbraCattiva.png", spawnTurn: 45 }, { name: "Ombra Cattivissima", hp: 25, attackDie: 10, attackBonus: 1, defenseDie: 8, defenseBonus: 1, iconUrl: "https://ste388.github.io/soldoro/img/OmbraCattivissima.png", spawnTurn: 55 } ];
  const ENEMY_DEFINITIONS = [ { name: "Orchetto", hp: 10, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 0 }, { name: "Orchetto", hp: 10, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 0 }, { name: "Orchetto", hp: 10, attackDie: 10, attackBonus: 0, defenseDie: 8, defenseBonus: 0 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 1 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 1, defenseDie: 6, defenseBonus: 0 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 0, defenseDie: 8, defenseBonus: 0 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 1, defenseDie: 8, defenseBonus: 0 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 1 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 1, defenseDie: 6, defenseBonus: 1 }, { name: "Troll", hp: 15, attackDie: 10, attackBonus: 0, defenseDie: 8, defenseBonus: 0 }, { name: "Troll", hp: 15, attackDie: 10, attackBonus: 1, defenseDie: 8, defenseBonus: 0 }, { name: "Troll", hp: 15, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 1 }, ];
  const NEW_SKULL_ICON_URL = 'https://ste388.github.io/soldoro/img/morte.png';
  const PRISONER_ICON_URL = 'https://ste388.github.io/soldoro/img/prigioniero.png';
  const CLASS_ICONS = { Guerriero: 'https://ste388.github.io/soldoro/img/guerriero.png', Esploratore: 'https://ste388.github.io/soldoro/img/esploratore.png', Ladro: 'https://ste388.github.io/soldoro/img/ladro.png' };
  const ENEMY_IMAGES = {
    orchetto: ['https://ste388.github.io/soldoro/img/orchetto1.png', 'https://ste388.github.io/soldoro/img/orchetto2.png', 'https://ste388.github.io/soldoro/img/orchetto3.png'],
    orco: ['https://ste388.github.io/soldoro/img/orco1.png', 'https://ste388.github.io/soldoro/img/orco2.png', 'https://ste388.github.io/soldoro/img/orco3.png', 'https://ste388.github.io/soldoro/img/orco4.png', 'https://ste388.github.io/soldoro/img/orco5.png', 'https://ste388.github.io/soldoro/img/orco6.png'],
    troll: ['https://ste388.github.io/soldoro/img/troll1.png', 'https://ste388.github.io/soldoro/img/troll2.png', 'https://ste388.github.io/soldoro/img/troll3.png'],
    boss: 'https://ste388.github.io/soldoro/img/bossFinale.png'
  };


  // ---- STATO DEL GIOCO ----
  let players = [];
  let currentPlayerIndex = 0;
  let numPlayers = 1;
  let creatingPlayerIndex = 0;
  
  let enemiesDefeatedCount, discoveryCounter;
  let visitedCells, enemyMap, bonusMap, potionMap, prisonerMap, altarMap, fountainMap, gasTrapPositions, gasActivatedPositions, holePositions, shadows, spawnedShadows;
  let gasEffect = { active: false, newCellsVisited: 0 };
  let fountainState;
  let prisonerQuests;
  let usedEnemyImages = { orchetto: new Set(), orco: new Set(), troll: new Set() };
  let messageQueue = [];
  let activeBattleState = null;
  let activeAbility = null;
  let selectedTradeItem = null;
  
  // ---- FUNZIONI PRINCIPALI ----
  function triggerScreenShake() { document.body.classList.add('shake'); setTimeout(() => document.body.classList.remove('shake'), 500); }
  
  function getRandomUniqueImage(type) {
    const images = ENEMY_IMAGES[type];
    const used = usedEnemyImages[type];
    let availableImages = images.filter(img => !used.has(img));
    if (availableImages.length === 0) {
        used.clear();
        availableImages = images;
    }
    const randomIndex = Math.floor(Math.random() * availableImages.length);
    const selectedImage = availableImages[randomIndex];
    used.add(selectedImage);
    return selectedImage;
  }

  function showBloodEffect() {
    return new Promise(resolve => {
        const modal = document.getElementById('itemFoundModal');
        const titleEl = document.getElementById('itemFoundTitle');
        const imgEl = document.getElementById('itemFoundImg');
        const nameEl = document.getElementById('itemFoundName');
        const extraTextEl = document.getElementById('itemFoundExtraText');
        const closeBtn = document.getElementById('itemFoundCloseBtn');

        modal.classList.add('overlay-effect');
        titleEl.style.display = 'none';
        nameEl.style.display = 'none';
        extraTextEl.style.display = 'none';
        closeBtn.style.display = 'none';
        imgEl.src = 'https://ste388.github.io/soldoro/img/sangue.png';
        imgEl.alt = 'Sangue';
        imgEl.classList.remove('splat-effect');

        modal.style.display = 'flex';
        modal.classList.add('shake');

        setTimeout(() => {
            modal.style.display = 'none';
            modal.classList.remove('shake');
            modal.classList.remove('overlay-effect');
            titleEl.style.display = 'block';
            nameEl.style.display = 'block';
            closeBtn.style.display = 'inline-block';
            resolve();
        }, 500);
    });
  }

  function showWeakHitEffect() {
    return new Promise(resolve => {
        const modal = document.getElementById('itemFoundModal');
        const titleEl = document.getElementById('itemFoundTitle');
        const imgEl = document.getElementById('itemFoundImg');
        const nameEl = document.getElementById('itemFoundName');
        const extraTextEl = document.getElementById('itemFoundExtraText');
        const closeBtn = document.getElementById('itemFoundCloseBtn');
        const weakBloodImages = [
            'https://ste388.github.io/soldoro/img/sangueDebole1.png',
            'https://ste388.github.io/soldoro/img/sangueDebole2.png',
            'https://ste388.github.io/soldoro/img/sangueDebole3.png',
            'https://ste388.github.io/soldoro/img/sangueDebole4.png',
        ];
        const selectedImage = weakBloodImages[Math.floor(Math.random() * weakBloodImages.length)];
        
        modal.classList.add('overlay-effect');
        titleEl.style.display = 'none';
        nameEl.style.display = 'none';
        extraTextEl.style.display = 'none';
        closeBtn.style.display = 'none';
        imgEl.src = selectedImage;
        imgEl.alt = 'Sangue Debole';
        imgEl.classList.add('splat-effect');
        
        modal.style.display = 'flex';

        setTimeout(() => {
            modal.style.display = 'none';
            modal.classList.remove('overlay-effect');
            imgEl.classList.remove('splat-effect');
            titleEl.style.display = 'block';
            nameEl.style.display = 'block';
            closeBtn.style.display = 'inline-block';
            resolve();
        }, 600);
    });
}

  function showParryEffect() {
    return new Promise(resolve => {
        const modal = document.getElementById('itemFoundModal');
        const titleEl = document.getElementById('itemFoundTitle');
        const imgEl = document.getElementById('itemFoundImg');
        const nameEl = document.getElementById('itemFoundName');
        const extraTextEl = document.getElementById('itemFoundExtraText');
        const closeBtn = document.getElementById('itemFoundCloseBtn');

        modal.classList.add('overlay-effect');
        titleEl.style.display = 'none';
        nameEl.style.display = 'none';
        extraTextEl.style.display = 'none';
        closeBtn.style.display = 'none';
        imgEl.src = 'https://ste388.github.io/soldoro/img/parata.png';
        imgEl.alt = 'Parata';
        imgEl.classList.remove('splat-effect');

        modal.style.display = 'flex';

        setTimeout(() => {
            modal.style.display = 'none';
            modal.classList.remove('overlay-effect');
            titleEl.style.display = 'block';
            nameEl.style.display = 'block';
            closeBtn.style.display = 'inline-block';
            resolve();
        }, 800);
    });
  }

  function showEventModal(title, iconUrl, name, extraText = '') {
    return new Promise(resolve => {
        const modal = document.getElementById('itemFoundModal');
        const titleEl = document.getElementById('itemFoundTitle');
        const imgEl = document.getElementById('itemFoundImg');
        const nameEl = document.getElementById('itemFoundName');
        const extraTextEl = document.getElementById('itemFoundExtraText');
        const closeBtn = document.getElementById('itemFoundCloseBtn');

        titleEl.textContent = title;
        imgEl.src = iconUrl;
        imgEl.alt = name;
        nameEl.textContent = name;
        extraTextEl.innerHTML = extraText.replace(/\n/g, '<br>');
        extraTextEl.style.display = extraText ? 'block' : 'none';

        const closeHandler = () => {
            modal.style.display = 'none';
            closeBtn.removeEventListener('click', closeHandler);
            resolve();
        };

        closeBtn.addEventListener('click', closeHandler);
        modal.style.display = 'block';
        closeBtn.focus();
    });
  }

  function updateEnergyUI() {
      if (players.length === 0) return;
      const character = players[currentPlayerIndex];
      if (!character) return;
      const cost = character.class === 'Guerriero' ? 4 : 5;
      energyValue.textContent = character.energy;
      
      const powerStrikeBtn = document.getElementById('powerStrikeBtn');
      if (powerStrikeBtn) powerStrikeBtn.disabled = character.energy < cost;

      const doubleAttackBtn = document.getElementById('doubleAttackBtn');
      if (doubleAttackBtn) doubleAttackBtn.disabled = character.energy < cost;
  }

  function gainEnergy(amount) {
      const character = players[currentPlayerIndex];
      if (!character) return;
      character.energy = Math.min(character.energy + amount, character.maxEnergy);
      updateEnergyUI();
  }

  function getAttackBonus(player, isAgainstShadow = false) {
      if (!player) return 0;
      const attackItemNames = ATTACK_BONUS_ITEMS.map(item => item.name);
      let bonus = player.bonuses.filter(b => attackItemNames.includes(b.name)).length;
      if (gasEffect.active && players.indexOf(player) === currentPlayerIndex) bonus -= 1;
      if (player.isCursed) bonus -= 2;
      if (isAgainstShadow && player.shadowSlayerBonus) bonus += player.shadowSlayerBonus;
      return bonus;
  }

  function getDefenseBonus(player) {
      if (!player) return 0;
      const defenseItemNames = DEFENSE_BONUS_ITEMS.map(item => item.name);
      return player.bonuses.filter(b => defenseItemNames.includes(b.name)).length;
  }
  
  function addSkullMarker(cell) { const contentDiv = cell.querySelector('.cell-content'); if (!contentDiv) return; contentDiv.innerHTML = ''; const img = document.createElement('img'); img.src = NEW_SKULL_ICON_URL; img.className = 'skull-marker'; contentDiv.appendChild(img); }
  function addPrisonerMarker(cell) { const contentDiv = cell.querySelector('.cell-content'); if (!contentDiv) return; contentDiv.innerHTML = ''; const img = document.createElement('img'); img.src = PRISONER_ICON_URL; img.className = 'prisoner-marker'; contentDiv.appendChild(img); }
  function addHoleMarker(cell) { const contentDiv = cell.querySelector('.cell-content'); if (!contentDiv) return; contentDiv.innerHTML = ''; const img = document.createElement('div'); img.className = 'hole-marker'; contentDiv.appendChild(img); }

  function removeGems(player) {
      const gemNames = new Set(GEMS.map(g => g.name));
      player.bonuses = player.bonuses.filter(bonus => !gemNames.has(bonus.name));
  }

  function addItemToInventory(player, item) {
    const existingItem = player.inventory.find(i => i.name === item.name);
    if (existingItem) {
        existingItem.quantity = (existingItem.quantity || 1) + 1;
    } else {
        player.inventory.push({ ...item, quantity: 1 });
    }
  }

  function updateDiscoveriesLog() {
      const lines = [];
      lines.push(`Celle esplorate: ${visitedCells ? visitedCells.size : 0}`);
      lines.push(`Nemici Uccisi (Totali): ${enemiesDefeatedCount} / 12`);
      lines.push('');
      players.forEach((player, idx) => {
          lines.push(`--- Giocatore ${idx + 1}: ${player.name} ---`);
          lines.push(`PF: ${Math.max(0, player.hp)} / ${player.maxHP}`);
          lines.push(`Energia: ${player.energy} / ${player.maxEnergy}`);
          const attackItemNames = ATTACK_BONUS_ITEMS.map(item => item.name);
          const attackBonuses = player.bonuses.filter(b => attackItemNames.includes(b.name));
          if (attackBonuses.length > 0) { lines.push('Bonus Attacco:'); attackBonuses.forEach(b => lines.push(`- ${b.name} (+1)`)); }
          const defenseItemNames = DEFENSE_BONUS_ITEMS.map(item => item.name);
          const defenseBonuses = player.bonuses.filter(b => defenseItemNames.includes(b.name));
          if (defenseBonuses.length > 0) { lines.push('Bonus Difesa:'); defenseBonuses.forEach(b => lines.push(`- ${b.name} (+1)`)); }
          
          if (player.inventory.length > 0) {
              lines.push('Pozioni:');
              player.inventory.forEach(p => {
                lines.push(`- ${p.name}` + (p.quantity > 1 ? ` (x${p.quantity})` : ''));
              });
          }

          const collectedGemNames = new Set(player.bonuses.map(b => b.name));
          const gemsToShow = GEMS.filter(g => collectedGemNames.has(g.name));
          if (gemsToShow.length > 0) { lines.push('Gemme:'); gemsToShow.forEach(gem => lines.push(`- ${gem.name}`)); }
          lines.push('Effetti:');
          let hasEffects = false;
          if (idx === currentPlayerIndex && gasEffect.active) { const remainingCells = GAS_EFFECT_DURATION_CELLS - gasEffect.newCellsVisited; lines.push(`- Gas Debolezza (-1 Atk per ${remainingCells} celle)`); hasEffects = true; }
          if (player.isCursed) { lines.push(`- Maledizione (-2 Attacco)`); hasEffects = true; }
          if (player.shadowSlayerBonus > 0) { lines.push(`- Benedizione (+${player.shadowSlayerBonus} Attacco vs Ombre)`); hasEffects = true; }
          if (!hasEffects) { lines.push('Nessuno'); }
          lines.push(`Prigionieri Liberati: ${player.prisonersFreed}`);
          lines.push(`Nemici Sconfitti: ${player.enemiesDefeated}`);
          lines.push('');
      });
      discoveriesLog.textContent = lines.join('\n');
  }

  function placeDiscoveries() {
      enemyMap = {}; bonusMap = {}; potionMap = {}; prisonerMap = {}; altarMap = {}; fountainMap = {}; gasTrapPositions = new Set(); gasActivatedPositions = new Set(); holePositions = new Set(); shadows = []; spawnedShadows = new Set(); prisonerQuests = { quests: {} }; fountainState = {};
      let availableCells = Array.from({length: CELL_COUNT}, (_, i) => i + 1).filter(cellNum => cellNum !== 1);
      for (let i = availableCells.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [availableCells[i], availableCells[j]] = [availableCells[j], availableCells[i]]; }
      for(let i=0; i<HOLE_COUNT; i++) { if(availableCells.length > 0) holePositions.add(availableCells.pop()); }
      for(let i = 0; i < ENEMY_COUNT; i++) { if(availableCells.length > 0) enemyMap[availableCells.pop()] = { name: 'Nemico Casuale' }; }
      ATTACK_BONUS_ITEMS.forEach(item => { if(availableCells.length > 0) bonusMap[availableCells.pop()] = item; });
      DEFENSE_BONUS_ITEMS.forEach(item => { if(availableCells.length > 0) bonusMap[availableCells.pop()] = item; });
      POTIONS.forEach(potion => { if(availableCells.length > 0) potionMap[availableCells.pop()] = potion; });
      GEMS.forEach(gem => { if(availableCells.length > 0) bonusMap[availableCells.pop()] = gem; });
      ALTARS.forEach(altar => { if(availableCells.length > 0) altarMap[availableCells.pop()] = altar; });
      
      if(availableCells.length > 0) {
        const fountainCell = availableCells.pop();
        fountainMap[fountainCell] = HEALING_FOUNTAIN;
        fountainState[fountainCell] = { used: false, cellsDiscoveredSinceUse: 0 };
      }

      if(availableCells.length > 0) bonusMap[availableCells.pop()] = GEM_DOOR;
      let prisonerCells = [];
      for (let i = 0; i < PRISONER_COUNT; i++) { if (availableCells.length > 0) { const cell = availableCells.pop(); prisonerMap[cell] = true; prisonerCells.push(cell); } }
      for (let i = 0; i < GAS_TRAP_COUNT; i++) { if (availableCells.length > 0) gasTrapPositions.add(availableCells.pop()); }
      if (prisonerCells.length >= 6) {
          for (let i = prisonerCells.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [prisonerCells[i], prisonerCells[j]] = [prisonerCells[j], prisonerCells[i]]; }
          let questGiver1 = prisonerCells.pop(); let target1 = prisonerCells.find(c => c > 36);
          if (target1) { prisonerCells.splice(prisonerCells.indexOf(target1), 1); prisonerQuests.quests[questGiver1] = { type: 'brother', targetCell: target1, reward: {name: 'Pozione (+5 PF)', value: 5, type: 'heal', iconUrl: "https://ste388.github.io/soldoro/img/pozione.png"}, status: 'inactive' }; prisonerQuests.quests[target1] = { type: 'brother-target', giver: questGiver1 }; }
          let questGiver2 = prisonerCells.pop(); let target2 = prisonerCells.find(c => c < 36);
          if (target2) { prisonerCells.splice(prisonerCells.indexOf(target2), 1); prisonerQuests.quests[questGiver2] = { type: 'father', targetCell: target2, reward: {name: 'Pozione Fuoco', type: 'fire', iconUrl: "https://ste388.github.io/soldoro/img/pozioneFuoco.png"}, status: 'inactive' }; prisonerQuests.quests[target2] = { type: 'father-target', giver: questGiver2 }; }
          let questGiver3 = prisonerCells.pop(); let target3 = prisonerCells.pop();
          if (questGiver3 && target3) { prisonerQuests.quests[questGiver3] = { type: 'mother', targetCell: target3, reward: {name: 'Fiala di Energia', type: 'energy', value: 999, iconUrl: 'https://ste388.github.io/soldoro/img/pozione.png'}, status: 'inactive' }; prisonerQuests.quests[target3] = { type: 'mother-target', giver: questGiver3 }; }
      }
  }
  
  function placeBoss() {
    const allCellNumbers = Array.from({length: CELL_COUNT}, (_, i) => i + 1);
    const occupiedCells = new Set(Array.from(visitedCells.keys()).map(Number));
    Object.keys(enemyMap).forEach(k => occupiedCells.add(Number(k)));
    Object.keys(bonusMap).forEach(k => occupiedCells.add(Number(k)));
    Object.keys(potionMap).forEach(k => occupiedCells.add(Number(k)));
    Object.keys(prisonerMap).forEach(k => occupiedCells.add(Number(k)));
    Object.keys(altarMap).forEach(k => occupiedCells.add(Number(k)));
    Object.keys(fountainMap).forEach(k => occupiedCells.add(Number(k)));
    holePositions.forEach(k => occupiedCells.add(Number(k)));
    const freeCells = allCellNumbers.filter(num => !occupiedCells.has(num));

    if (freeCells.length > 0) {
        const bossCellNum = freeCells[Math.floor(Math.random() * freeCells.length)];
        enemyMap[bossCellNum] = { name: 'Boss Finale', isBoss: true };
        playSound('bossAppear');
        messageQueue.push("Un'oscura presenza è apparsa nel dungeon...");
    } else {
        stopSound('background');
        const gameLostSound = sounds.gameLost;
        if (gameLostSound) {
            gameLostSound.volume = 0.8;
            gameLostSound.currentTime = 0;
            gameLostSound.play().catch(e => console.warn("Game Lost sound failed:", e));
        }
        messageQueue.push({
            endGame: true,
            title: "Dungeon non depurato!",
            subtitle: "Il Dungeon non è stato completamente depurato, il boss finale non vuole mostrarsi, riprova avrai più fortuna..."
        });
    }
  }

  function buildBoard() {
      board.innerHTML = '';
      for (let i = 1; i <= CELL_COUNT; i++) {
          const r = Math.floor((i - 1) / COLS); const c = (i - 1) % COLS;
          const cellDiv = document.createElement('div'); cellDiv.className = 'cell'; cellDiv.dataset.cellNumber = i; cellDiv.dataset.row = r; cellDiv.dataset.col = c;
          const content = document.createElement('div'); content.className = 'cell-content'; cellDiv.appendChild(content);
          
          if (visitedCells && visitedCells.has(String(i))) {
              cellDiv.classList.add('visited'); const info = visitedCells.get(String(i)); content.innerHTML = '';
              if (info.altar && info.altar.type === 'purification') { cellDiv.classList.add('purification-altar-border'); }
              if (info.defeated) addSkullMarker(cellDiv);
              else if (info.prisonerFreed) addPrisonerMarker(cellDiv);
              else if (holePositions.has(i)) addHoleMarker(cellDiv);
              else if (info.fountain) { const img = document.createElement('img'); img.src = info.fountain.iconUrl; img.className = 'item-marker'; content.appendChild(img); }
              else if (info.altar) { const img = document.createElement('img'); img.src = info.altar.iconUrl; img.className = 'item-marker'; content.appendChild(img); }
              else if (info.bonus && info.bonus.iconUrl) { const img = document.createElement('img'); img.src = info.bonus.iconUrl; img.className = 'item-marker'; content.appendChild(img); }
              else if (info.potion && info.potion.iconUrl) { const img = document.createElement('img'); img.src = info.potion.iconUrl; img.className = 'item-marker'; content.appendChild(img); }
              else { content.textContent = i; }
              if (info.enemy && !info.defeated) content.appendChild(Object.assign(document.createElement('div'), { className: 'enemy-marker' }));
              if (info.bonus && info.bonus.name === GEM_DOOR.name) cellDiv.classList.add('gem-door-marker');
          } else { content.textContent = i; }

          const shadowHere = shadows.find(s => s.position === i && s.hp > 0);
          if (shadowHere) { const img = document.createElement('img'); img.src = shadowHere.iconUrl; img.className = 'shadow-marker'; content.appendChild(img); }
          players.forEach((p, index) => { if (p.position === i && (!activeBattleState || p.position !== activeBattleState.battleCellNum)) { const img = document.createElement('img'); img.src = CLASS_ICONS[p.class]; img.className = 'hero-marker'; content.appendChild(img); if (index === currentPlayerIndex && !activeBattleState) { cellDiv.classList.add(`current-player-${index + 1}`); } } });
          if (gasActivatedPositions.has(i)) content.appendChild(Object.assign(document.createElement('div'), { className: 'gas-marker' }));
          board.appendChild(cellDiv);
      }
  }
  
  function getValidMoves(steps) {
      const character = players[currentPlayerIndex];
      if (!character) return [];
      const startCell = board.querySelector(`[data-cell-number="${character.position}"]`);
      if (!startCell) return [];
      const startRow = startCell.dataset.row, startCol = startCell.dataset.col;
      return [...board.querySelectorAll('.cell')].filter(cell => {
          if (cell === startCell) return false;
          const r = cell.dataset.row, c = cell.dataset.col;
          const dr = Math.abs(r - startRow), dc = Math.abs(c - startCol);
          return Math.max(dr, dc) === steps;
      });
  }
  
  function clearHighlights() { board.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted')); }

  function processMessageQueue(onComplete) {
      messageModal.classList.remove('victory-modal'); victorySubText.textContent = ''; prisonerStatusText.textContent = '';
      if (messageQueue.length > 0) {
          const message = messageQueue.shift();
          if (typeof message === 'object' && message.victory) { 
              messageModal.classList.add('victory-modal'); 
              messageModalText.textContent = message.title; 
              victorySubText.textContent = message.subtitle; 
              prisonerStatusText.textContent = message.prisonerStatus; 
          } else if (typeof message === 'object' && message.endGame) { 
              messageModal.classList.add('victory-modal'); 
              messageModalText.textContent = message.title; 
              victorySubText.textContent = message.subtitle; 
              messageModal.style.display = 'block'; 
              playerActions.innerHTML = ''; 
              messageModalOkBtn.onclick = () => { 
                  messageModal.style.display = 'none'; 
                  promptForNewGame(); 
              }; 
              return; 
          } else { 
              messageModalText.innerHTML = message; 
          }
          messageModal.style.display = 'block';
          messageModalOkBtn.onclick = () => {
              messageModal.style.display = 'none';
              processMessageQueue(onComplete);
          };
          messageModalOkBtn.focus();
      } else {
          messageModal.style.display = 'none';
          if (onComplete) onComplete();
      }
  }
  
  function setMainMessage(text, color = '#ffcc00') { mainMessageDisplay.textContent = text; mainMessageDisplay.style.color = color; mainMessageDisplay.style.visibility = text ? 'visible' : 'hidden'; }
  function resetMessages() { setMainMessage(''); }
  
  function setBattleMode(isBattle) {
      if (isBattle) {
          stickyControls.style.top = '-200px';
          sounds.background.pause();
          playSound('battle');
      } else {
          activeBattleState = null;
          stickyControls.style.top = '0';
          stopSound('battle');
          playSound('background');
      }
      buildBoard();
  }

  function findPath(start, end) {
      let queue = [[start]]; let visited = new Set([start]);
      while(queue.length > 0) {
          let path = queue.shift(); let pos = path[path.length - 1]; if(pos === end) return path;
          let neighbors = [pos - 1, pos + 1, pos - COLS, pos + COLS, pos-COLS-1, pos-COLS+1, pos+COLS-1, pos+COLS+1].filter(n => {
              if (n < 1 || n > CELL_COUNT || visited.has(n)) return false;
              const r1 = Math.floor((pos - 1) / COLS), c1 = (pos - 1) % COLS;
              const r2 = Math.floor((n - 1) / COLS), c2 = (n - 1) % COLS;
              return Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1;
          });
          neighbors.sort((a,b) => {
              const distA = Math.abs(Math.floor((a-1)/COLS) - Math.floor((end-1)/COLS)) + Math.abs(((a-1)%COLS) - ((end-1)%COLS));
              const distB = Math.abs(Math.floor((b-1)/COLS) - Math.floor((end-1)/COLS)) + Math.abs(((b-1)%COLS) - ((end-1)%COLS));
              return distA - distB;
          });
          for (const neighbor of neighbors) { if (!visited.has(neighbor)) { visited.add(neighbor); let newPath = [...path, neighbor]; queue.push(newPath); } }
      }
      return null;
  }
  
  async function animateAndSetCurrent(destinationCell) {
      playerActions.innerHTML = '<button id="diceRollBtn" disabled>Tira dado</button>';
      clearHighlights(); diceRes.textContent = '-'; const character = players[currentPlayerIndex];
      const startNum = character.position; const endNum = parseInt(destinationCell.dataset.cellNumber); const path = findPath(startNum, endNum);
      if (!path || path.length <= 1) { character.position = endNum; await processCellLogic(destinationCell); return; }
      for (let i = 1; i < path.length; i++) { await new Promise(resolve => setTimeout(resolve, 150)); playSound('step'); character.position = path[i]; buildBoard(); }
      await processCellLogic(destinationCell);
  }

  async function processCellLogic(cell) {
    const character = players[currentPlayerIndex];
    const cellNum = parseInt(cell.dataset.cellNumber);
    character.position = cellNum;
    resetMessages();
    let subsequentAction;

    const isNewVisit = !visitedCells.has(String(cellNum));
    
    if (isNewVisit) {
        if (visitedCells.size > 0 && visitedCells.size % 2 === 0) {
            gainEnergy(1);
        }
        Object.keys(fountainState).forEach(cellKey => {
            const state = fountainState[cellKey];
            if (state.used) {
                state.cellsDiscoveredSinceUse++;
                const cellsNeeded = numPlayers === 1 ? 5 : 10;
                if (state.cellsDiscoveredSinceUse >= cellsNeeded) {
                    state.used = false;
                    state.cellsDiscoveredSinceUse = 0;
                    messageQueue.push("La fontana ha ripreso il suo potere curativo");
                }
            }
        });
    }

    if (isNewVisit) {
        discoveryCounter++;
        visitedCells.set(String(cellNum), { enemy: null, bonus: null, potion: null, altar: null, fountain: null, prisonerFreed: false, collected: false, defeated: false, hp: 0, discoveryOrder: discoveryCounter });
        
        const info = visitedCells.get(String(cellNum));
        info.enemy = enemyMap[cellNum] ? { ...enemyMap[cellNum] } : null;
        info.bonus = bonusMap[cellNum] ? { ...bonusMap[cellNum] } : null;
        info.potion = potionMap[cellNum] ? { ...potionMap[cellNum] } : null;
        info.altar = altarMap[cellNum] ? { ...altarMap[cellNum] } : null;
        info.fountain = fountainMap[cellNum] ? { ...fountainMap[cellNum] } : null;

        if (holePositions.has(cellNum)) { 
          const damage = character.class === 'Esploratore' ? 2 : 3; 
          playSound('hole'); 
          triggerScreenShake(); 
          addHoleMarker(cell); 
          await showEventModal("Sei bloccato in un buco!", HOLE_IMAGE_URL, `-${damage} PF`);
          character.hp -= damage; 
          if (character.hp <= 0) { subsequentAction = () => handleGameOver("per una caviglia slogata", character); processMessageQueue(subsequentAction); return; } 
        }
        
        if (gasEffect.active) { gasEffect.newCellsVisited++; if (gasEffect.newCellsVisited >= GAS_EFFECT_DURATION_CELLS) { gasEffect.active = false; gasEffect.newCellsVisited = 0; messageQueue.push("L'effetto del gas di debolezza è svanito!"); } }
        
        if (visitedCells.size > 0 && visitedCells.size % 7 === 0) {
            const healAmount = 3;
            character.hp = Math.min(character.hp + healAmount, character.maxHP);
            await showEventModal("Riposo", 'https://ste388.github.io/soldoro/img/riposo.png', `Il riposo ti ha fatto recuperare ${healAmount} PF`);
        }

        if (gasTrapPositions.has(cellNum) && !gasActivatedPositions.has(cellNum)) {
          playSound('gas');
          gasEffect.active = true;
          gasEffect.newCellsVisited = 0;
          gasActivatedPositions.add(cellNum);
          await showEventModal(
              "Trappola a Gas!",
              'https://ste388.github.io/soldoro/img/trappolaGas.png',
              "Sei finito in una trappola a gas!",
              `Attacco -1 finché non scopri ${GAS_EFFECT_DURATION_CELLS} nuove celle.`
          );
        }
        if (info.bonus) {
            if (info.bonus.name === GEM_DOOR.name) {
                await showEventModal("Porta di Gemme", GEM_DOOR.iconUrl, "La porta è sigillata ermeticamente.");
            } else if (!character.bonuses.some(b => b.name === info.bonus.name)) {
                character.bonuses.push(info.bonus);
                playSound('item');
                const isBonusItem = ATTACK_BONUS_ITEMS.some(i => i.name === info.bonus.name) || DEFENSE_BONUS_ITEMS.some(i => i.name === info.bonus.name);
                const modalText = isBonusItem ? `${info.bonus.name} +1` : info.bonus.name;
                await showEventModal("Hai trovato", info.bonus.iconUrl, modalText);
            }
        }
        if (info.potion) {
            if (!info.collected) {
                addItemToInventory(character, info.potion);
                playSound('item');
                info.collected = true;
                await showEventModal("Hai trovato", info.potion.iconUrl, info.potion.name);
            }
        }
        if (prisonerMap[cellNum] && !visitedCells.get(String(cellNum)).prisonerFreed) { await handlePrisonerQuest(cellNum); }
    } else {
        const info = visitedCells.get(String(cellNum));
        if (info && info.bonus && info.bonus.name === GEM_DOOR.name) {
            const hasAllGems = GEMS.every(gem => character.bonuses.some(b => b.name === gem.name));
            if (hasAllGems && !character.hasSpecialSword) {
                character.hasSpecialSword = true;
                playSound('item');
                const specialSword = { name: "Spada Speciale", iconUrl: "https://ste388.github.io/soldoro/img/elsa.png" };
                await showEventModal("La Porta si apre!", specialSword.iconUrl, "Spada Speciale (1D12+1)", "All'interno trovi una spada magica!");
                removeGems(character);
            }
        }
    }

    if (numPlayers > 1) {
      const otherPlayerIndex = (currentPlayerIndex + 1) % 2;
      if (players.length > 1 && players[otherPlayerIndex].position === cellNum) {
          showTradeButton();
      } else {
          hideTradeButton();
      }
    }

    const currentCellInfo = visitedCells.get(String(cellNum)) || {};
    
    if (currentCellInfo.fountain) { await handleFountain(cellNum); return; }
    if (currentCellInfo.altar) { subsequentAction = () => handleAltar(currentCellInfo.altar); } 
    else {
      const shadowAtLocation = shadows.find(s => s.position === cellNum && s.hp > 0);
      if (shadowAtLocation) { subsequentAction = () => startBattle(shadowAtLocation); } 
      else if (currentCellInfo && currentCellInfo.enemy && !currentCellInfo.defeated) { subsequentAction = () => handleEncounter(currentCellInfo.enemy); } 
      else {
        if (currentCellInfo && currentCellInfo.enemy && currentCellInfo.defeated) setMainMessage('Qui giace un nemico sconfitto.', '#a9a9a9'); 
        else if (isNewVisit && cellNum !== 1) setMainMessage('Procedi tranquillo', 'lightgreen'); 
        else if (!isNewVisit) setMainMessage('Cella già visitata', '#ffffff');
        subsequentAction = () => endTurnSequence();
      }
    }
    
    updatePlayerInfo(); updateDiscoveriesLog(); buildBoard();
    processMessageQueue(subsequentAction);
  }
  
  async function handleFountain(cellNum) {
    playSound('fountain');
    const character = players[currentPlayerIndex];
    const state = fountainState[cellNum];

    const info = visitedCells.get(String(cellNum));
    await showEventModal("Hai trovato", info.fountain.iconUrl, info.fountain.name, "Una fonte di acqua limpida e pura.");
    
    if (state && !state.used) {
        fountainModal.style.display = 'block';
        fountainMessage.textContent = "Vuoi bere e recuperare 10 PF?";
        fountainActions.innerHTML = '';
        
        const yesBtn = document.createElement('button');
        yesBtn.textContent = 'Sì';
        yesBtn.onclick = () => {
            character.hp = Math.min(character.hp + 10, character.maxHP);
            messageQueue.push("Hai bevuto e recuperato 10 PF!");
            playSound('drink');
            state.used = true;
            state.cellsDiscoveredSinceUse = 0;
            fountainModal.style.display = 'none';
            processMessageQueue(() => {
                updatePlayerInfo();
                updateDiscoveriesLog();
                endTurnSequence();
            });
        };

        const noBtn = document.createElement('button');
        noBtn.textContent = 'No';
        noBtn.onclick = () => {
            messageQueue.push("Hai deciso di non bere per ora.");
            fountainModal.style.display = 'none';
            processMessageQueue(endTurnSequence);
        };
        
        fountainActions.appendChild(yesBtn);
        fountainActions.appendChild(noBtn);

    } else {
        messageQueue.push('La fontana è prosciugata. Ha bisogno di tempo per ricaricarsi.');
        processMessageQueue(endTurnSequence);
    }
  }


  async function handleAltar(altar) {
    const character = players[currentPlayerIndex];
    if (altar.type === 'sacrificial') {
        await showEventModal("Altare Sacrificale", altar.iconUrl, "Un altare oscuro...", "Puoi sacrificare 4 PF per una benedizione (+2 Attacco vs Ombre).");
        altarModal.style.display = 'block';
        altarMessage.textContent = "Accetti il sacrificio?";
        altarActions.innerHTML = '';
        const yesBtn = document.createElement('button');
        yesBtn.textContent = 'Sì';
        yesBtn.onclick = () => {
            playSound('hit');
            character.hp -= 4;
            character.shadowSlayerBonus = 2;
            altarModal.style.display = 'none';
            processMessageQueue(() => {
                if (character.hp <= 0) handleGameOver("sacrificandosi all'altare", character);
                else endTurnSequence();
            });
        };
        const noBtn = document.createElement('button');
        noBtn.textContent = 'No';
        noBtn.onclick = () => {
            altarModal.style.display = 'none';
            endTurnSequence();
        };
        altarActions.appendChild(yesBtn);
        altarActions.appendChild(noBtn);
    } else if (altar.type === 'curse') {
        playSound('curse');
        if (!character.isCursed) {
            character.isCursed = true;
            await showEventModal("Maledizione!", altar.iconUrl, "-2 Attacco", "Sei stato maledetto! Trova un altare purificatore.");
        } else {
            await showEventModal("Aura Maligna", altar.iconUrl, "Nessun effetto", "Senti un'aura maligna, ma sei già maledetto.");
        }
        processMessageQueue(endTurnSequence);
    } else if (altar.type === 'purification') {
        if (character.isCursed) {
            character.isCursed = false;
            playSound('removeCurse');
            await showEventModal("Purificazione!", altar.iconUrl, "Maledizione rimossa", "L'aura benefica dell'altare ti purifica!");
        } else {
            await showEventModal("Altare Purificatore", altar.iconUrl, "Nessun effetto", "Senti un'aura di pace, ma non hai maledizioni.");
        }
        processMessageQueue(endTurnSequence);
    }
}

  async function handlePrisonerQuest(cellNum) {
    const character = players[currentPlayerIndex];
    const quest = prisonerQuests.quests[cellNum];
    const info = visitedCells.get(String(cellNum));
    
    character.prisonersFreed++;
    info.prisonerFreed = true;
    playSound('prisoner');
    
    if (!quest) {
      await showEventModal("Hai liberato", PRISONER_ICON_URL, "Prigioniero");
      return;
    }

    if (quest.status === 'inactive') {
        quest.status = 'active';
        character.activeQuests = character.activeQuests || [];
        character.activeQuests.push(cellNum);

        let familyMember = '', locationInfo = '', possessive = '', pronoun = '';
        if (quest.type === 'brother') { familyMember = 'fratello'; locationInfo = 'nella parte nord'; possessive = 'Mio'; pronoun = 'lui'; }
        else if (quest.type === 'father') { familyMember = 'padre'; locationInfo = 'nella parte sud'; possessive = 'Mio'; pronoun = 'lui'; }
        else if (quest.type === 'mother') { familyMember = 'madre'; locationInfo = 'qui vicino'; possessive = 'Mia'; pronoun = 'lei'; }
        
        const targetCellInfo = visitedCells.get(String(quest.targetCell));
        if (targetCellInfo && targetCellInfo.prisonerFreed) {
            quest.status = 'completed';
            addItemToInventory(character, quest.reward);
            playSound('item');
            const questText = `"Grazie! Ho saputo che ${possessive.toLowerCase()} ${familyMember} è già in salvo! Prendi questa ricompensa!"`;
            await showEventModal("Missione Completata!", quest.reward.iconUrl, quest.reward.name, questText);
        } else if (familyMember) {
            const questText = `Grazie! ${possessive} ${familyMember} è ${locationInfo} (cella ${quest.targetCell}). Se liberi anche ${pronoun}, ti ricompenserò!`;
            await showEventModal("Hai liberato", PRISONER_ICON_URL, "Prigioniero", questText, 5000);
        }
    } else if (quest.type.includes('-target')) {
        const giverQuest = prisonerQuests.quests[quest.giver];
        if (giverQuest && giverQuest.status === 'active') {
            giverQuest.status = 'completed';
            let questOriginator = players.find(p => p.activeQuests && p.activeQuests.includes(quest.giver)) || character;
            if (questOriginator.activeQuests) { questOriginator.activeQuests = questOriginator.activeQuests.filter(q => q !== quest.giver); }
            
            addItemToInventory(questOriginator, giverQuest.reward);
            playSound('item');
            const rewardText = `Il parente è stato trovato! La ricompensa è per ${questOriginator.name}.`;
            await showEventModal("Missione Completata!", giverQuest.reward.iconUrl, giverQuest.reward.name, rewardText);
        } else {
            await showEventModal("Hai liberato", PRISONER_ICON_URL, "Prigioniero");
        }
    }
}
  
  async function endTurnSequence() {
      if (activeBattleState) return;
      hideTradeButton();
      let battleStarted = false;
      const exploredCount = visitedCells.size;
      for (const spawn of SHADOW_SPAWNS) {
          if (exploredCount >= spawn.spawnTurn && !spawnedShadows.has(spawn.name)) {
              spawnedShadows.add(spawn.name);
              playSound('shadow');
              let freeCells = Array.from({length: CELL_COUNT}, (_, i) => i + 1).filter(c => c !== players[currentPlayerIndex].position && !shadows.some(s => s.position === c));
              if(freeCells.length > 0) {
                  const pos = freeCells[Math.floor(Math.random() * freeCells.length)];
                  shadows.push({ ...spawn, hp: spawn.hp, startHP: spawn.hp, position: pos, isShadow: true });
                  messageQueue.push(`${spawn.name} è apparsa nel dungeon!`);
                  await new Promise(resolve => processMessageQueue(resolve));
                  buildBoard();
              }
          }
      }

      if (shadows.some(s => s.hp > 0)) {
          shadowActionDisplay.style.display = 'block';
          for (const shadow of shadows) {
              if (shadow.hp > 0) {
                  await new Promise(resolve => setTimeout(resolve, 1000));
                  shadowTurnName.textContent = shadow.name;
                  const moveRoll = Math.floor(Math.random() * 6) + 1;
                  playSound('dice');
                  shadowDiceRes.textContent = moveRoll;
                  await new Promise(resolve => setTimeout(resolve, 500));
                  for(let i=0; i<moveRoll; i++) {
                      if (battleStarted) break;
                      let path = findPath(shadow.position, players[currentPlayerIndex].position);
                      if (path && path.length > 1) {
                          shadow.position = path[1];
                          buildBoard();
                          await new Promise(resolve => setTimeout(resolve, 200));
                      }
                      if (shadow.position === players[currentPlayerIndex].position) {
                          startBattle(shadow);
                          battleStarted = true;
                          break;
                      }
                  }
                  if(battleStarted) break;
              }
          }
          shadowActionDisplay.style.display = 'none';
      }

      if (!battleStarted) {
          endTurnAndSwitchPlayer();
      }
  }

  function endTurnAndSwitchPlayer() {
      if (numPlayers > 1) {
        currentPlayerIndex = (currentPlayerIndex + 1) % numPlayers;
      }
      updatePlayerInfo();
      updateDiscoveriesLog();
      buildBoard();
      updatePlayerActions();
      setMainMessage(`Tocca a ${players[currentPlayerIndex].name}!`, '#ffeb3b');
  }
  
  async function handleEncounter(enemy) {
    playerActions.innerHTML = '';
    const definition = enemy.isBoss ? { name: 'Boss Finale', hp: 30, attackDie: 10, attackBonus: 2, defenseDie: 8, defenseBonus: 2, isBoss: true } : ENEMY_DEFINITIONS[enemiesDefeatedCount];
    let finalEnemy = { ...enemy, ...definition, startHP: definition.hp, name: definition.name };

    let enemyTypeForImage;
    if (finalEnemy.isBoss) {
        finalEnemy.imageUrl = ENEMY_IMAGES.boss;
    } else {
        if (enemiesDefeatedCount < 3) enemyTypeForImage = 'orchetto';
        else if (enemiesDefeatedCount < 9) enemyTypeForImage = 'orco';
        else enemyTypeForImage = 'troll';
        finalEnemy.imageUrl = getRandomUniqueImage(enemyTypeForImage);
        playSound(`trovo${enemyTypeForImage.charAt(0).toUpperCase() + enemyTypeForImage.slice(1)}`);
    }

    encounterModal.style.display = 'block';
    encounterContent.innerHTML = `
        <p style="font-weight: bold; font-size: 20px; color: #ffeb3b;">Hai incontrato un nemico!</p>
        <img src="${finalEnemy.imageUrl}" alt="${finalEnemy.name}" style="width: 150px; height: 150px; border-radius: 8px; border: 2px solid #555; margin: 10px 0;">
        <p style="font-size: 18px; margin-bottom: 20px;">${finalEnemy.name}</p>
    `;

    encounterActionBtns.innerHTML = '';
    
    if (!finalEnemy.isBoss) {
        const rollBtn = document.createElement('button');
        rollBtn.textContent = 'Tenta di nasconderti (D6)';
        rollBtn.onclick = () => {
            handleHideAttempt(finalEnemy);
        };
        encounterActionBtns.appendChild(rollBtn);
    }

    const battleBtn = document.createElement('button');
    battleBtn.textContent = 'Vai in battaglia';
    battleBtn.onclick = () => {
        encounterModal.style.display = 'none';
        startBattle(finalEnemy);
    };
    encounterActionBtns.appendChild(battleBtn);
}

function handleHideAttempt(enemy) {
    const rollBtn = encounterActionBtns.querySelector('button:first-child');
    const battleBtn = encounterActionBtns.querySelector('button:last-child');
    rollBtn.disabled = true;
    battleBtn.disabled = true;

    let flips = 10;
    playSound('dice');
    const diceResultDiv = document.createElement('div');
    diceResultDiv.style.fontSize = "48px";
    diceResultDiv.style.fontWeight = "bold";
    encounterContent.appendChild(diceResultDiv);

    const timer = setInterval(() => {
        diceResultDiv.textContent = Math.floor(Math.random() * 6) + 1;
        if (--flips === 0) {
            clearInterval(timer);
            let roll = Number(diceResultDiv.textContent);
            let success = roll >= 4;
            if (players[currentPlayerIndex].class === 'Ladro') success = roll >= 3;
            
            encounterActionBtns.innerHTML = ''; 
            const resultMsg = document.createElement('p');
            
            if (success) {
                resultMsg.textContent = "Sei riuscito a nasconderti!";
                resultMsg.style.color = "lightgreen";
                setTimeout(async () => { 
                    encounterModal.style.display = 'none';
                    await endTurnSequence();
                }, 2000);
            } else {
                resultMsg.textContent = "Sei stato visto! Inizia la battaglia.";
                resultMsg.style.color = "red";
                setTimeout(() => {
                    encounterModal.style.display = 'none';
                    startBattle(enemy);
                }, 2000);
            }
            encounterContent.appendChild(resultMsg);
        }
    }, 100);
}


  function getFinalPrisonerMessage() {
    const totalPrisonersFreed = players.reduce((sum, p) => sum + (p.prisonersFreed || 0), 0);
    if (totalPrisonersFreed === 11) return `Prigionieri liberati: ${totalPrisonersFreed}. Siete stati portati a festa come eroi liberatori!`;
    if (totalPrisonersFreed >= 9) return `Prigionieri liberati: ${totalPrisonersFreed}. Un cittadino piange il figlio perduto sulla sua tomba.`;
    if (totalPrisonersFreed >= 5) return `Prigionieri liberati: ${totalPrisonersFreed}. I cittadini sono tristi per i prigionieri non liberati.`;
    return `Prigionieri liberati: ${totalPrisonersFreed}. I cittadini piangono i loro cari non liberati.`;
  }

  function handleGameOver(source, deadPlayer) {
    if (activeBattleState && activeBattleState.enemy.isBoss) {
        playSound('gameLost');
    } else {
        playSound('death');
    }
    battleModal.style.display = 'none';
    initiativeModal.style.display = 'none';
    allyChoiceModal.style.display = 'none';
    supportAttackModal.style.display = 'none';
    setBattleMode(false);

    if (numPlayers === 2) {
      const continueSolo = confirm(`Il personaggio ${deadPlayer.name} è morto, vuoi continuare l'avventura in solitaria?`);
      if (continueSolo) {
          players = players.filter(p => p !== deadPlayer);
          numPlayers = 1;
          currentPlayerIndex = 0;
          messageQueue.push(`${players[0].name} continua da solo l'avventura.`);
          processMessageQueue(() => {
            updatePlayerInfo();
            updateDiscoveriesLog();
            buildBoard();
            updatePlayerActions();
            endTurnSequence();
          });
          return;
      }
    }
    
    stopSound('background');
    const prisonerMessage = getFinalPrisonerMessage();
    const gameOverTitle = `GAME OVER\n${deadPlayer.name} è stato sconfitto ${source}.`;
    const gameOverSubtitle = `Nemici uccisi: ${enemiesDefeatedCount}\n${prisonerMessage}`;
    
    messageQueue.push({ endGame: true, title: gameOverTitle, subtitle: gameOverSubtitle });
    processMessageQueue();
  }

  function attemptEscape() {
      initiativeModal.style.display = 'none';
      battleModal.style.display = 'block';
      battleActionContainer.innerHTML = '';
      battleResult.innerHTML = 'Tenti la fuga...';
      battleResult.style.color = '#ffcc00';
      battleResult.style.fontSize = '18px';
      const character = players[activeBattleState.primaryCombatantIndex];
      let flips = 10;
      playSound('dice');
      const timer = setInterval(() => {
          let dieSize = character.class === 'Ladro' ? 4 : 6;
          battlePlayerDice.textContent = Math.floor(Math.random() * dieSize) + 1;
          if (--flips === 0) {
              clearInterval(timer);
              const damageRoll = Number(battlePlayerDice.textContent);
              playSound('hit');
              character.hp -= damageRoll;
              updatePlayerInfo();
              if (character.hp <= 0) {
                  handleGameOver("durante la fuga", character);
              } else {
                  battleModal.style.display = 'none';
                  setBattleMode(false);
                  messageQueue.push(`Fuga riuscita! Ma hai perso ${damageRoll} PF.`);
                  processMessageQueue(async () => await endTurnSequence());
              }
          }
      }, 100);
  }

  function startBattle(enemy) {
    setBattleMode(true);
    const character = players[currentPlayerIndex];
    if (!character) return;
    
    const cellInfo = visitedCells.get(String(character.position));
    let currentEnemyHP = enemy.isShadow ? enemy.hp : (cellInfo && cellInfo.hp > 0 ? cellInfo.hp : enemy.startHP);
    if (cellInfo && !enemy.isShadow) cellInfo.hp = currentEnemyHP;

    activeBattleState = {
        enemy: { ...enemy, hp: currentEnemyHP, startHP: enemy.startHP },
        primaryCombatantIndex: currentPlayerIndex,
        primaryCombatantName: character.name,
        battleCellNum: character.position,
        isAllyJoined: false,
        helpRequested: false,
        roundPhase: 'mainPlayer'
    };
    
    const otherPlayerIndex = (currentPlayerIndex + 1) % numPlayers;
    if (numPlayers > 1 && players.length > 1 && players[otherPlayerIndex].position === character.position) {
        activeBattleState.isAllyJoined = true;
    }

    battleLog.textContent = '';
    startCombatRound();
  }

  function startCombatRound() {
      if (!activeBattleState) return;
      if (activeBattleState.roundPhase === 'mainPlayer') {
          startInitiativePhase(false);
      } else if (activeBattleState.roundPhase === 'ally' && activeBattleState.isAllyJoined) {
          startInitiativePhase(true);
      } else {
          activeBattleState.roundPhase = 'mainPlayer';
          startInitiativePhase(false);
      }
  }


  function startInitiativePhase(isSupportRound) {
    if (!activeBattleState) return;
    battleModal.style.display = 'none';
    
    document.querySelectorAll('#initiativeModal .battle-unit').forEach(el => el.classList.remove('highlight-winner'));

    let combatant1, combatant2;
    if (isSupportRound) {
        combatant1 = players[(activeBattleState.primaryCombatantIndex + 1) % 2];
        combatant2 = activeBattleState.enemy;
        initiativeMessage.textContent = `Iniziativa Supporto: ${combatant1.name} vs ${combatant2.name}`;
    } else {
        combatant1 = players.find(p => p.name === activeBattleState.primaryCombatantName) || players[activeBattleState.primaryCombatantIndex];
        combatant2 = activeBattleState.enemy;
        initiativeMessage.textContent = `Iniziativa: ${combatant1.name} vs ${combatant2.name}`;
    }

    initiativePlayerName.textContent = combatant1.name;
    initiativePlayerStats.textContent = `PF: ${combatant1.hp} | Energia: ${combatant1.energy}`;
    initiativeEnemyName.textContent = combatant2.name;
    initiativeEnemyStats.textContent = `PF: ${combatant2.hp}`;
    
    initiativePlayerDice.textContent = '-';
    initiativeEnemyDice.textContent = '-';
    initiativeResult.textContent = '';
    initiativeModal.style.display = 'block';
    initiativeRollBtn.style.display = 'block';
    initiativeRollBtn.disabled = false;
    
    usePotionInitiativeBtn.style.display = 'none';
    if (!isSupportRound) {
        usePotionInitiativeBtn.style.display = 'block';
        usePotionInitiativeBtn.disabled = combatant1.inventory.filter(p => p.type === 'heal' || p.type === 'energy').length === 0;
        usePotionInitiativeBtn.onclick = () => openInitiativePotionSelect();
    }

    initiativeRollBtn.onclick = () => {
        initiativeRollBtn.disabled = true;
        usePotionInitiativeBtn.style.display = 'none';
        
        animateAndRoll(initiativePlayerDice, 6, 0, (roll1) => {
            animateAndRoll(initiativeEnemyDice, 6, 0, (roll2) => {
                setTimeout(() => {
                    const winner = roll1 >= roll2 ? combatant1 : combatant2;
                    initiativeResult.textContent = `${winner.name} ha l'iniziativa!`;
                    
                    if (winner === combatant1) {
                        initiativePlayerName.closest('.battle-unit').classList.add('highlight-winner');
                    } else {
                        initiativeEnemyName.closest('.battle-unit').classList.add('highlight-winner');
                    }
                    
                    setTimeout(() => {
                        initiativeModal.style.display = 'none';
                        let attacker = winner;
                        let defender = (attacker === combatant1) ? combatant2 : combatant1;
                        prepareAttackPhase(attacker, defender, isSupportRound);
                    }, 2000);
                }, 2000); 
            });
        });
    };
  }

  function prepareAttackPhase(attacker, defender, isSupportRound) {
    if (!activeBattleState) return;
    
    battleModal.style.display = 'flex';
    updateBattleUI();

    const isPlayerAttacker = players.includes(attacker);
    battleResult.innerHTML = `Tocca a ${attacker.name} attaccare!`;
    battleActionContainer.innerHTML = '';
    specialAbilitiesContainer.innerHTML = '';
    
    if (isPlayerAttacker) {
        specialAbilitiesContainer.style.visibility = 'visible';
        
        const attackBtn = document.createElement('button');
        attackBtn.textContent = 'Attacco Normale';
        attackBtn.onclick = () => { 
            activeAbility = null;
            resolveAttack(attacker, defender); 
        };
        battleActionContainer.appendChild(attackBtn);

        if (!isSupportRound) {
            if (!defender.isShadow && !defender.isBoss) {
                const escapeBtn = document.createElement('button');
                escapeBtn.textContent = `Fuggi (subisci 1D${attacker.class === 'Ladro' ? 4 : 6} PF)`;
                escapeBtn.onclick = attemptEscape;
                battleActionContainer.appendChild(escapeBtn);
            }

            const cost = attacker.class === 'Guerriero' ? 4 : 5;
            const powerStrikeBtn = document.createElement('button');
            powerStrikeBtn.id = 'powerStrikeBtn';
            powerStrikeBtn.title = 'Un attacco che non può essere parato';
            powerStrikeBtn.textContent = `Colpo Potente (${cost})`;
            powerStrikeBtn.onclick = () => { if (attacker.energy >= cost) { attacker.energy -= cost; activeAbility = 'powerStrike'; resolveAttack(attacker, defender); } };
            specialAbilitiesContainer.appendChild(powerStrikeBtn);

            const doubleAttackBtn = document.createElement('button');
            doubleAttackBtn.id = 'doubleAttackBtn';
            doubleAttackBtn.title = 'Esegui due tiri di attacco in un turno';
            doubleAttackBtn.textContent = `Doppio Attacco (${cost})`;
            doubleAttackBtn.onclick = () => { if (attacker.energy >= cost) { attacker.energy -= cost; activeAbility = 'doubleAttack'; resolveAttack(attacker, defender); } };
            specialAbilitiesContainer.appendChild(doubleAttackBtn);

             const usePotionBattleBtn = document.createElement('button');
             usePotionBattleBtn.textContent = 'Usa Pozione';
             usePotionBattleBtn.onclick = () => openBattlePotionSelect(attacker);
             specialAbilitiesContainer.appendChild(usePotionBattleBtn);
            
            if (numPlayers > 1 && !activeBattleState.isAllyJoined && !activeBattleState.helpRequested) {
                const askHelpBtn = document.createElement('button');
                askHelpBtn.textContent = 'Chiedi Soccorso';
                askHelpBtn.classList.add('intervention-btn');
                askHelpBtn.onclick = askForHelp;
                specialAbilitiesContainer.appendChild(askHelpBtn);
            }
        } else { // Alleato attaccante
            const usePotionBattleBtn = document.createElement('button');
             usePotionBattleBtn.textContent = 'Usa Pozione';
             usePotionBattleBtn.onclick = () => openBattlePotionSelect(attacker);
             specialAbilitiesContainer.appendChild(usePotionBattleBtn);
        }
        updateEnergyUI();
    } else { // Turno del nemico
        specialAbilitiesContainer.style.visibility = 'hidden';
        setTimeout(() => resolveAttack(attacker, defender), 2000);
    }
  }
  
  function updateBattleUI() {
    if (!activeBattleState) return;
    const mainPlayer = players.find(p => p.name === activeBattleState.primaryCombatantName) || players[activeBattleState.primaryCombatantIndex];
    if(!mainPlayer) return;
    const enemy = activeBattleState.enemy;

    // Main Player
    battlePlayerName.textContent = mainPlayer.name;
    battlePlayerPF.textContent = `PF: ${Math.max(0, mainPlayer.hp)} / ${mainPlayer.maxHP}`;
    const mainPlayerAttackBonus = getAttackBonus(mainPlayer, enemy.isShadow) + (mainPlayer.hasSpecialSword ? 1 : 0);
    const mainPlayerAttackDie = mainPlayer.hasSpecialSword ? 12 : mainPlayer.attackDie;
    battlePlayerAttack.textContent = `Attacco: 1D${mainPlayerAttackDie}${mainPlayerAttackBonus >= 0 ? '+' + mainPlayerAttackBonus : mainPlayerAttackBonus}`;
    battlePlayerDefense.textContent = `Difesa: 1D${mainPlayer.defenseDie}${getDefenseBonus(mainPlayer) > 0 ? '+' + getDefenseBonus(mainPlayer) : ''}`;

    // Ally
    if (activeBattleState.isAllyJoined && numPlayers > 1) {
        const allyPlayer = players.find(p => p !== mainPlayer);
        if(allyPlayer) {
          allyBattleUnit.style.display = 'block';
          allyJoinedIndicator.style.display = 'block';
          battleAllyName.textContent = allyPlayer.name;
          battleAllyPF.textContent = `PF: ${Math.max(0, allyPlayer.hp)} / ${allyPlayer.maxHP}`;
          const allyAttackBonus = getAttackBonus(allyPlayer, enemy.isShadow) + (allyPlayer.hasSpecialSword ? 1 : 0);
          const allyAttackDie = allyPlayer.hasSpecialSword ? 12 : allyPlayer.attackDie;
          battleAllyAttack.textContent = `Attacco: 1D${allyAttackDie}${allyAttackBonus >= 0 ? '+' + allyAttackBonus : allyAttackBonus}`;
          battleAllyDefense.textContent = `Difesa: 1D${allyPlayer.defenseDie}${getDefenseBonus(allyPlayer) > 0 ? '+' + getDefenseBonus(allyPlayer) : ''}`;
        }
    } else {
        allyBattleUnit.style.display = 'none';
        allyJoinedIndicator.style.display = 'none';
    }
    
    // Enemy
    battleEnemyName.textContent = enemy.name;
    battleEnemyPF.textContent = `PF: ${Math.max(0, enemy.hp)} / ${enemy.startHP}`;
    battleEnemyAttack.textContent = `Attacco: 1D${enemy.attackDie}+${enemy.attackBonus || 0}`;
    battleEnemyDefense.textContent = `Difesa: 1D${enemy.defenseDie}+${enemy.defenseBonus || 0}`;

    battlePlayerDice.textContent = '-';
    battleAllyDice.textContent = '-';
    battleEnemyDice.textContent = '-';
    updateEnergyUI();
  }

  function animateMainDice(callback) {
      playSound('dice');
      let flips = 10;
      const timer = setInterval(() => {
          diceRes.textContent = Math.floor(Math.random() * 6) + 1;
          if (--flips === 0) {
              clearInterval(timer);
              const finalRoll = Math.floor(Math.random() * 6) + 1;
              diceRes.textContent = finalRoll;
              callback(finalRoll);
          }
      }, 100);
  }

  function animateAndRoll(targetEl, die, bonus, callback) {
        playSound('dice');
        let flips = 10;
        const timer = setInterval(() => {
            targetEl.textContent = Math.floor(Math.random() * die) + 1;
            if (--flips === 0) {
                clearInterval(timer);
                const roll = Math.floor(Math.random() * die) + 1;
                const total = roll + bonus;
                targetEl.textContent = total;
                callback(total);
            }
        }, 80);
    }
    
  async function resolveAttack(attacker, defender) {
    battleActionContainer.innerHTML = '';
    specialAbilitiesContainer.style.visibility = 'hidden';
    
    const isPlayerAttacker = players.includes(attacker);
    
    const getAttackerAttackDie = () => isPlayerAttacker ? (attacker.hasSpecialSword ? 12 : attacker.attackDie) : attacker.attackDie;
    const getAttackerAttackBonus = () => isPlayerAttacker ? getAttackBonus(attacker, defender.isShadow) : (attacker.attackBonus || 0);
    const getDefenderDefenseDie = () => players.includes(defender) ? defender.defenseDie : defender.defenseDie;
    const getDefenderDefenseBonus = () => players.includes(defender) ? getDefenseBonus(defender) : (defender.defenseBonus || 0);
    
    let attackerDiceEl, defenderDiceEl;
    if (isPlayerAttacker) {
        attackerDiceEl = (attacker.name === activeBattleState.primaryCombatantName) ? battlePlayerDice : battleAllyDice;
        defenderDiceEl = battleEnemyDice;
    } else {
        attackerDiceEl = battleEnemyDice;
        defenderDiceEl = (defender.name === activeBattleState.primaryCombatantName) ? battlePlayerDice : battleAllyDice;
    }


    async function processCombatResult(attackRoll, defenseRoll) {
        const damage = Math.max(0, attackRoll - defenseRoll);
        defender.hp -= damage;
        
        if (damage > 0) {
            battleResult.innerHTML = `${defender.name} subisce ${damage} danni!`;
            battleResult.style.color = players.includes(defender) ? 'red' : 'lightgreen';
        } else {
            battleResult.innerHTML = `Attacco parato!`;
            battleResult.style.color = 'deepskyblue';
        }

        await new Promise(resolve => setTimeout(resolve, 500));
        
        if (damage >= 3) {
            playSound('powerhit');
            await Promise.all([showBloodEffect(), triggerScreenShake()]);
        } else if (damage > 0) { // Danno tra 1 e 2
            playSound('hit');
            await showWeakHitEffect();
        } else { // Danno 0, parata
            playSound('parry');
            await showParryEffect();
        }
        
        setTimeout(finalizePhase, 1480);
    }

     if (activeAbility === 'doubleAttack' && isPlayerAttacker) {
        let totalDamage = 0;
        animateAndRoll(attackerDiceEl, getAttackerAttackDie(), getAttackerAttackBonus(), async (attack1) => {
            animateAndRoll(defenderDiceEl, getDefenderDefenseDie(), getDefenderDefenseBonus(), async (defense1) => {
                const damage1 = Math.max(0, attack1 - defense1);
                totalDamage += damage1;
                
                await new Promise(r => setTimeout(r, 500));
                if (damage1 > 0) {
                   if (damage1 >= 3) { playSound('powerhit'); await Promise.all([showBloodEffect(), triggerScreenShake()]); } 
                   else { playSound('hit'); await showWeakHitEffect(); }
                }

                await new Promise(r => setTimeout(r, 500));

                animateAndRoll(attackerDiceEl, getAttackerAttackDie(), getAttackerAttackBonus(), async (attack2) => {
                    animateAndRoll(defenderDiceEl, getDefenderDefenseDie(), getDefenderDefenseBonus(), async (defense2) => {
                        const damage2 = Math.max(0, attack2 - defense2);
                        totalDamage += damage2;

                        await new Promise(r => setTimeout(r, 500));
                        if (damage2 > 0) {
                           if (damage2 >= 3) { playSound('powerhit'); await Promise.all([showBloodEffect(), triggerScreenShake()]); } 
                           else { playSound('hit'); await showWeakHitEffect(); }
                        }
                        
                        defender.hp -= totalDamage; 
                        battleResult.innerHTML = `Doppio Attacco! Danno Totale: ${totalDamage}`;
                        setTimeout(finalizePhase, 1480);
                    });
                });
            });
        });
    } else if (activeAbility === 'powerStrike' && isPlayerAttacker) {
        animateAndRoll(attackerDiceEl, getAttackerAttackDie(), getAttackerAttackBonus(), async (attackRoll) => {
            defenderDiceEl.textContent = 'X';
            battleResult.innerHTML = `Colpo Potente! Danno inflitto: ${attackRoll}`;
            
            await new Promise(resolve => setTimeout(resolve, 500));
            
            if (attackRoll > 0) {
                if (attackRoll >= 3) {
                    playSound('powerhit');
                    await Promise.all([showBloodEffect(), triggerScreenShake()]);
                } else {
                    playSound('hit');
                    await showWeakHitEffect();
                }
            }
            defender.hp -= attackRoll; 
            setTimeout(finalizePhase, 1480);
        });
    } else {
        animateAndRoll(attackerDiceEl, getAttackerAttackDie(), getAttackerAttackBonus(), (attackRoll) => {
            animateAndRoll(defenderDiceEl, getDefenderDefenseDie(), getDefenderDefenseBonus(), (defenseRoll) => {
                processCombatResult(attackRoll, defenseRoll);
            });
        });
    }
  }
  
  function finalizePhase() {
    if (!activeBattleState) return;
    activeAbility = null;
    updateBattleUI();

    let deadPlayer = null;
    for (const player of players) {
        if (player.hp <= 0) {
            deadPlayer = player;
            break;
        }
    }
    
    if (deadPlayer) {
      setTimeout(() => handleGameOver("in combattimento", deadPlayer), 1500);
      return;
    }
    
    if (activeBattleState.enemy.hp <= 0) {
        setTimeout(() => endBattleVictoriously(), 1500);
        return;
    }

    if (activeBattleState.roundPhase === 'mainPlayer') {
        activeBattleState.roundPhase = 'ally';
    } else {
        activeBattleState.roundPhase = 'mainPlayer';
    }
    startCombatRound();
  }

  function endBattleVictoriously(){
    const combatant = players.find(p => p.name === activeBattleState.primaryCombatantName) || players[activeBattleState.primaryCombatantIndex];
    const enemy = activeBattleState.enemy;
    gainEnergy(3);
    
    battleResult.innerHTML = "VITTORIA!<br>Hai sconfitto il nemico.";
    battleResult.style.color = 'lightgreen';

    if (enemy.isShadow) {
        playSound('deathShadow');
        shadows = shadows.filter(s => s.name !== enemy.name);
    } else if (enemy.isBoss) {
        playSound('bossDeath');
        battleResult.innerHTML = "VITTORIA!<br>Hai sconfitto il Boss Finale!";
        const dungeonLiberatedBtn = document.createElement('button');
        dungeonLiberatedBtn.textContent = 'Dungeon liberato';
        dungeonLiberatedBtn.onclick = () => {
            playSound('gameWin');
            battleModal.style.display = 'none';
            setBattleMode(false);
            const prisonerMessage = getFinalPrisonerMessage();
            messageQueue.push({ 
                endGame: true, 
                title: "DUNGEON LIBERATO!", 
                subtitle: `Hai sconfitto il Boss Finale!\n${prisonerMessage}`
            });
            processMessageQueue();
        };
        battleActionContainer.innerHTML = '';
        specialAbilitiesContainer.innerHTML = '';
        battleActionContainer.appendChild(dungeonLiberatedBtn);
        return;
    } else {
        if (deathSoundToggle) {
            playSound('death2');
        } else {
            playSound('death');
        }
        deathSoundToggle = !deathSoundToggle;
        enemiesDefeatedCount++;
        combatant.enemiesDefeated = (combatant.enemiesDefeated || 0) + 1;
        if (enemiesDefeatedCount === ENEMY_COUNT) placeBoss();
    }
    
    const cellInfo = visitedCells.get(String(combatant.position));
    if (cellInfo) cellInfo.defeated = true;

    updateDiscoveriesLog();
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Continua...';
    closeBtn.onclick = async () => {
        battleModal.style.display = 'none';
        setBattleMode(false);
        await endTurnSequence();
    };
    battleActionContainer.innerHTML = '';
    specialAbilitiesContainer.innerHTML = '';
    battleActionContainer.appendChild(closeBtn);
  }
  
  function askForHelp() {
      if (!activeBattleState) return;
      activeBattleState.helpRequested = true;
      battleActionContainer.innerHTML = '';
      specialAbilitiesContainer.innerHTML = '';
      battleResult.innerHTML = 'Hai chiesto aiuto...';
      
      currentPlayerIndex = (currentPlayerIndex + 1) % numPlayers;
      updatePlayerInfo();
      updatePlayerActions();
  }

  function showAllyChoiceModal() {
      battleModal.style.display = 'none';
      allyChoiceModal.style.display = 'block';
  }

  function updatePlayerActions() {
      playerActions.innerHTML = '';
      const diceButton = document.createElement('button');
      diceButton.id = 'diceRollBtn';
      diceButton.textContent = 'Tira dado';
      diceButton.onclick = rollDice;
      playerActions.appendChild(diceButton);
      
      hideTradeButton();
      if (numPlayers > 1 && players.length > 1 && players[0].position === players[1].position) {
        showTradeButton();
      }

      if (activeBattleState) {
          diceButton.disabled = true;
          if (currentPlayerIndex !== activeBattleState.primaryCombatantIndex && activeBattleState.helpRequested) {
              showAllyChoiceModal();
              allyChoiceMessage.textContent = `${activeBattleState.primaryCombatantName} chiede il tuo aiuto! Cosa fai?`;
              allyChoiceActions.innerHTML = '';

              const interveneBtn = document.createElement('button');
              interveneBtn.textContent = 'Intervieni';
              interveneBtn.classList.add('intervention-btn');
              interveneBtn.onclick = () => {
                  attemptIntervention();
              };
              allyChoiceActions.appendChild(interveneBtn);

              const ignoreBtn = document.createElement('button');
              ignoreBtn.textContent = 'Ignora';
              ignoreBtn.classList.add('ignore-btn');
              ignoreBtn.onclick = () => {
                  activeBattleState.helpRequested = false;
                  setMainMessage('Hai ignorato la richiesta di aiuto.', 'orange');
                  currentPlayerIndex = activeBattleState.primaryCombatantIndex;
                  updatePlayerInfo();
                  allyChoiceModal.style.display = 'none';
                  startCombatRound();
              };
              allyChoiceActions.appendChild(ignoreBtn);

          }
      }
  }

  async function attemptIntervention() {
    allyChoiceActions.innerHTML = '';
    const ally = players[currentPlayerIndex];
    const battleCellNum = activeBattleState.battleCellNum;
    const path = findPath(ally.position, battleCellNum);
    const distance = path ? path.length - 1 : -1;

    if (distance <= 0) {
        allyChoiceModal.style.display = 'none';
        messageQueue.push("Sei già sul posto! Ti unisci alla lotta.");
        processMessageQueue(() => {
            activeBattleState.isAllyJoined = true;
            activeBattleState.helpRequested = false;
            currentPlayerIndex = activeBattleState.primaryCombatantIndex;
            updatePlayerInfo();
            startCombatRound();
        });
        return;
    }

    allyChoiceMessage.textContent = `Ti serve un ${distance} o più per raggiungere la battaglia!`;
    const rollBtn = document.createElement('button');
    rollBtn.textContent = 'Lancia per Intervenire';
    allyChoiceActions.appendChild(rollBtn);

    rollBtn.onclick = () => {
        rollBtn.disabled = true;
        allyChoiceMessage.textContent = `Lancio in corso...`;
        animateMainDice(async (roll) => {
            allyChoiceMessage.textContent = `Hai ottenuto: ${roll}`;
            await new Promise(resolve => setTimeout(resolve, 2000));

            if (roll >= distance) {
                allyChoiceModal.style.display = 'none';
                messageQueue.push("Sei arrivato in tempo! Ti unisci alla lotta.");
                const movePath = path;
                for (let i = 1; i < movePath.length; i++) {
                    await new Promise(resolve => setTimeout(resolve, 150));
                    playSound('step');
                    ally.position = movePath[i];
                    buildBoard();
                }
                activeBattleState.isAllyJoined = true;
                activeBattleState.helpRequested = false;
                processMessageQueue(() => {
                    currentPlayerIndex = activeBattleState.primaryCombatantIndex;
                    updatePlayerInfo();
                    startCombatRound();
                });
            } else {
                allyChoiceModal.style.display = 'none';
                messageQueue.push(`Non sei abbastanza veloce! Percorri ${roll} caselle ma la battaglia continua senza di te.`);
                const movePath = path.slice(0, roll + 1);
                if (movePath.length > 1) {
                  for (let i = 1; i < movePath.length; i++) {
                      await new Promise(resolve => setTimeout(resolve, 150));
                      playSound('step');
                      ally.position = movePath[i];
                      buildBoard();
                  }
                }
                activeBattleState.helpRequested = false;
                processMessageQueue(() => {
                    currentPlayerIndex = activeBattleState.primaryCombatantIndex;
                    updatePlayerInfo();
                    startCombatRound();
                });
            }
        });
    };
  }


  function updatePlayerInfo() {
      if (players.length === 0 || !players[currentPlayerIndex]) { playerInfo.textContent = 'Crea un personaggio'; energyValue.textContent = '0'; return; }
      const character = players[currentPlayerIndex]; playerInfo.textContent = `${character.name} (G${currentPlayerIndex+1}) | PF: ${Math.max(0, character.hp)} / ${character.maxHP}`; playerInfo.className = `player-1-info`; if (currentPlayerIndex === 1) playerInfo.className = `player-2-info`; updateEnergyUI();
  }

  function wireCellListeners() { board.addEventListener('click', event => { const target = event.target.closest('.cell'); if (target && target.classList.contains('highlighted')) { animateAndSetCurrent(target); } }); }
  
  async function rollDice() {
    const btn = document.getElementById('diceRollBtn');
    if (!btn || btn.disabled) return;
    btn.disabled = true;
    resetMessages();
    animateMainDice(async (roll) => {
        const moves = getValidMoves(roll);
        if (moves.length === 0) {
            triggerScreenShake();
            playSound('vines');
            const character = players[currentPlayerIndex];
            const damage = character.class === 'Esploratore' ? 1 : 3;
            await showEventModal("Sei bloccato!", 'https://ste388.github.io/soldoro/img/rampicante.png', `Perdi ${damage} PF`);
            character.hp -= damage;
            updatePlayerInfo();
            if (character.hp <= 0) {
                handleGameOver("intrappolato dai rampicanti", character);
            } else {
                await endTurnSequence();
            }
        } else {
            moves.forEach(cell => cell.classList.add('highlighted'));
        }
    });
  }
  
  async function startGame() {
      players.forEach(p => { 
        p.position = 1; 
        p.bonuses = p.bonuses || []; 
        p.inventory = [];
        p.hasSpecialSword = p.hasSpecialSword || false; 
        p.prisonersFreed = p.prisonersFreed || 0; 
        p.enemiesDefeated = 0; // Inizializza il contatore
        p.isCursed = p.isCursed || false; 
        p.shadowSlayerBonus = p.shadowSlayerBonus || 0; 
        p.activeQuests = p.activeQuests || []; 
        addItemToInventory(p, { name: "Pozione (+5 PF)", value: 5, type: "heal", iconUrl: "https://ste388.github.io/soldoro/img/pozione.png" });
        addItemToInventory(p, { name: "Fiala di Energia", value: 5, type: "energy", iconUrl: 'https://ste388.github.io/soldoro/img/pozione.png' });
      });

      visitedCells = new Map(); enemiesDefeatedCount = 0; discoveryCounter = 1; gasEffect = { active: false, newCellsVisited: 0 }; shadows = []; spawnedShadows = new Set(); messageQueue = [];
      usedEnemyImages = { orchetto: new Set(), orco: new Set(), troll: new Set() };
      placeDiscoveries(); buildBoard();
      const firstPlayer = players[0]; const startCell = board.querySelector(`[data-cell-number="${firstPlayer.position}"]`);
      await processCellLogic(startCell);
      updateLayout(); updatePlayerInfo(); updateDiscoveriesLog(); charForm.style.display = 'none';
  }
  
  function promptForNewGame() {
      resetMessages(); board.innerHTML = ''; discoveriesLog.textContent = ''; players = []; currentPlayerIndex = 0; activeBattleState = null; updatePlayerInfo(); diceRes.textContent = '-'; updatePlayerActions();
      tradeModal.style.display = 'none';
      playerCountModal.style.display = 'block';
  }

  function showCharacterCreationForm() {
    charFormTitle.textContent = `Crea Personaggio per Giocatore ${creatingPlayerIndex + 1}`;
    document.getElementById('charName').value = '';
    const charHPInput = document.getElementById('charHP');
    charHPInput.value = 35; 
    charForm.style.display = 'block';
  }


  function saveGame() {
      if (players.length === 0) { alert("Nessun gioco da salvare. Inizia una nuova partita prima."); return; }
      const gameState = { players, currentPlayerIndex, numPlayers, enemiesDefeatedCount, discoveryCounter, visitedCells: Array.from(visitedCells.entries()), enemyMap, bonusMap, potionMap, prisonerMap, altarMap, fountainMap, fountainState, gasTrapPositions: Array.from(gasTrapPositions), gasActivatedPositions: Array.from(gasActivatedPositions), holePositions: Array.from(holePositions), gasEffect, shadows, spawnedShadows: Array.from(spawnedShadows), prisonerQuests, activeBattleState, usedEnemyImages: { orchetto: Array.from(usedEnemyImages.orchetto), orco: Array.from(usedEnemyImages.orco), troll: Array.from(usedEnemyImages.troll) } };
      localStorage.setItem('dungeon72Save', JSON.stringify(gameState)); alert('Partita salvata!'); loadGameBtn.style.display = 'block';
  }

  async function loadGame() {
      if (!audioInitialized) initAudio();
      const savedStateJSON = localStorage.getItem('dungeon72Save'); if (!savedStateJSON) { promptForNewGame(); return; }
      const savedState = JSON.parse(savedStateJSON);
      players = savedState.players; currentPlayerIndex = savedState.currentPlayerIndex; numPlayers = savedState.numPlayers; enemiesDefeatedCount = savedState.enemiesDefeatedCount; discoveryCounter = savedState.discoveryCounter; visitedCells = new Map(savedState.visitedCells);
      enemyMap = savedState.enemyMap; bonusMap = savedState.bonusMap; potionMap = savedState.potionMap; prisonerMap = savedState.prisonerMap; altarMap = savedState.altarMap; fountainMap = savedState.fountainMap; fountainState = savedState.fountainState; gasTrapPositions = new Set(savedState.gasTrapPositions); gasActivatedPositions = new Set(savedState.gasActivatedPositions); holePositions = new Set(savedState.holePositions); gasEffect = savedState.gasEffect; shadows = savedState.shadows; spawnedShadows = new Set(savedState.spawnedShadows); prisonerQuests = savedState.prisonerQuests; activeBattleState = savedState.activeBattleState;
      if (savedState.usedEnemyImages) { usedEnemyImages = { orchetto: new Set(savedState.usedEnemyImages.orchetto), orco: new Set(savedState.usedEnemyImages.orco), troll: new Set(savedState.usedEnemyImages.troll) }; } else { usedEnemyImages = { orchetto: new Set(), orco: new Set(), troll: new Set() }; }
      messageQueue = []; buildBoard(); updateLayout(); updatePlayerInfo(); updateDiscoveriesLog(); resetMessages(); charForm.style.display = 'none'; playerCountModal.style.display = 'none';
      if (activeBattleState) { setBattleMode(true); startCombatRound(); }
      else { updatePlayerActions(); }
      alert('Partita caricata!');
  }

  function updateLayout() { const discoveriesLog = document.getElementById('discoveriesLog'); const leftColumn = document.getElementById('left'); const centerColumn = document.getElementById('center-column'); const isDesktop = window.innerWidth > 1024; if (isDesktop) { if (discoveriesLog.parentElement !== leftColumn) { leftColumn.appendChild(discoveriesLog); } } else { if (discoveriesLog.parentElement !== centerColumn) { centerColumn.appendChild(discoveriesLog); } } }
  
  function openBattlePotionSelect(player) {
    if (!activeBattleState || !player) return;
    battlePotionList.innerHTML = '';
    if (player.inventory.length === 0) return;
    
    player.inventory.forEach(potion => { 
        const btn = document.createElement('button'); 
        btn.textContent = `${potion.name} (x${potion.quantity})`;
        btn.onclick = () => { 
            battlePotionSelectModal.style.display = 'none';
            usePotionInBattle(potion, player); 
        }; 
        battlePotionList.appendChild(btn); 
    });
    battlePotionSelectModal.style.display = 'block';
  }

  function openInitiativePotionSelect() {
    if (!activeBattleState) return;
    const character = players[activeBattleState.primaryCombatantIndex];
    battlePotionList.innerHTML = '';
    const usablePotions = character.inventory.filter(p => p.type === 'heal' || p.type === 'energy');
    
    if (usablePotions.length === 0) return;
    
    usablePotions.forEach(potion => {
        const btn = document.createElement('button');
        btn.textContent = `${potion.name} (x${potion.quantity})`;
        btn.onclick = () => {
            battlePotionSelectModal.style.display = 'none';
            usePotionInInitiative(potion);
        };
        battlePotionList.appendChild(btn);
    });
    battlePotionSelectModal.style.display = 'block';
  }
  
  function usePotionInInitiative(potion){
    if (!activeBattleState) return;
    const character = players[activeBattleState.primaryCombatantIndex];
    
    potion.quantity--;
    playSound('drink');
    let logMessage = '';
    if (potion.type === 'heal') {
        const oldHp = character.hp;
        character.hp = Math.min(character.hp + potion.value, character.maxHP);
        const healedAmount = character.hp - oldHp;
        logMessage = `${character.name} usa ${potion.name} e recupera ${healedAmount} PF!`;
    } else if (potion.type === 'energy') {
        const oldEnergy = character.energy;
        character.energy = Math.min(character.energy + potion.value, character.maxEnergy);
        const gainedAmount = character.energy - oldEnergy;
        logMessage = `${character.name} usa ${potion.name} e recupera ${gainedAmount} Energia!`;
    }
    
    if (potion.quantity <= 0) {
        character.inventory = character.inventory.filter(p => p.name !== potion.name);
    }
    
    updatePlayerInfo();
    updateDiscoveriesLog();
    initiativePlayerStats.textContent = `PF: ${character.hp} | Energia: ${character.energy}`;
    initiativeResult.textContent = logMessage;
    setTimeout(() => { if (initiativeResult.textContent === logMessage) { initiativeResult.textContent = ''; } }, 2000);
    usePotionInitiativeBtn.disabled = character.inventory.filter(p => (p.type === 'heal' || p.type === 'energy') && p.quantity > 0).length === 0;
  }
  
  function usePotionInBattle(potion, player) {
    if (!activeBattleState || !player) return;
    
    potion.quantity--;

    if (potion.type === 'heal' || potion.type === 'energy') { 
        playSound('drink');
        if (potion.type === 'heal') {
            const oldHp = player.hp; 
            player.hp = Math.min(player.hp + potion.value, player.maxHP); 
            const healedAmount = player.hp - oldHp; 
            battleResult.innerHTML = `${player.name} recupera ${healedAmount} PF! Ora ha ${player.hp} PF.`; 
        } else { // energy
            const oldEnergy = player.energy; 
            player.energy = Math.min(player.energy + potion.value, player.maxEnergy);
            const gainedAmount = player.energy - oldEnergy; 
            battleResult.innerHTML = `${player.name} recupera ${gainedAmount} Energia!`;
        }
        updateBattleUI();
        updateDiscoveriesLog();
        setTimeout(finalizePhase, 2000); 
    } else if (potion.type === 'fire' || potion.type === 'ice') {
         potionDamageModal.style.display = 'block';
         potionDamageTitle.textContent = `Usa ${potion.name}`;
         potionDamageDice.textContent = '-';
         potionDamageRollBtn.disabled = false;
         potionDamageRollBtn.onclick = () => {
             playSound('throw');
             potionDamageRollBtn.disabled = true;
             let flips = 10;
             playSound('dice');
             const timer = setInterval(() => {
                 potionDamageDice.textContent = Math.floor(Math.random() * 6) + 1;
                 if (--flips === 0) {
                     clearInterval(timer);
                     const damage = Number(potionDamageDice.textContent);
                     potionDamageModal.style.display = 'none';
                     const enemy = activeBattleState.enemy;
                     playSound('hit');
                     if (damage >= 3) triggerScreenShake();
                     enemy.hp -= damage;
                     let resultText = `${potion.name} infligge ${damage} danni!`;
                     if (potion.type === 'fire') {
                         enemy.effects = enemy.effects || [];
                         enemy.effects = enemy.effects.filter(e => e.type !== 'burn');
                         enemy.effects.push({ type: 'burn', duration: 2, damage: [3, 2] });
                         resultText += ` Il nemico sta andando a fuoco!`;
                     } else if (potion.type === 'ice') {
                         const heroAttackRoll = Math.floor(Math.random() * (player.hasSpecialSword ? 12 : player.attackDie) + 1) + getAttackBonus(player, enemy.isShadow);
                         playSound('hit');
                         if (heroAttackRoll >= 3) triggerScreenShake();
                         enemy.hp -= heroAttackRoll;
                         resultText += ` Colpo extra da ${heroAttackRoll} danni!`;
                     }
                     battleResult.innerHTML = resultText;
                     updateDiscoveriesLog();
                     setTimeout(finalizePhase, 2000);
                 }
             }, 100);
         }
    }
    
    if (potion.quantity <= 0) {
        player.inventory = player.inventory.filter(p => p.name !== potion.name);
    }
  }

  function showTradeButton() {
    let tradeBtn = document.getElementById('tradeBtn');
    if (!tradeBtn) {
        tradeBtn = document.createElement('button');
        tradeBtn.id = 'tradeBtn';
        tradeBtn.textContent = 'Scambia Oggetti';
        tradeBtn.onclick = openTradeModal;
        stickyControls.appendChild(tradeBtn);
    }
    tradeBtn.style.display = 'inline-block';
  }

  function hideTradeButton() {
    const tradeBtn = document.getElementById('tradeBtn');
    if (tradeBtn) {
        tradeBtn.style.display = 'none';
    }
  }

  function openTradeModal() {
    if(numPlayers < 2) return;
    updateTradeInventories();
    tradeModal.style.display = 'flex';
  }

  function updateTradeInventories() {
    player1InventoryList.innerHTML = '';
    player2InventoryList.innerHTML = '';
    if(players.length < 2) return;
    document.getElementById('tradePlayer1Name').textContent = players[0].name;
    document.getElementById('tradePlayer2Name').textContent = players[1].name;
    
    let allItems1 = [...players[0].inventory.map(item => ({...item})), ...players[0].bonuses.map(item => ({...item}))];
    let allItems2 = [...players[1].inventory.map(item => ({...item})), ...players[1].bonuses.map(item => ({...item}))];

    allItems1.forEach(item => {
        if(item.name === GEM_DOOR.name) return;
        const li = document.createElement('li');
        li.textContent = item.name + (item.quantity > 1 ? ` (x${item.quantity})` : '');
        li.dataset.itemName = item.name;
        li.dataset.isPotion = !!item.quantity;
        li.dataset.player = 0;
        player1InventoryList.appendChild(li);
    });

    allItems2.forEach(item => {
        if(item.name === GEM_DOOR.name) return;
        const li = document.createElement('li');
        li.textContent = item.name + (item.quantity > 1 ? ` (x${item.quantity})` : '');
        li.dataset.itemName = item.name;
        li.dataset.isPotion = !!item.quantity;
        li.dataset.player = 1;
        player2InventoryList.appendChild(li);
    });
    selectedTradeItem = null;
    toPlayer1Btn.disabled = true;
    toPlayer2Btn.disabled = true;
  }

  function handleTradeSelection(e) {
    const target = e.target;
    if (target.tagName !== 'LI') return;

    document.querySelectorAll('#tradeModal .inventory-list li').forEach(li => li.classList.remove('selected'));
    
    target.classList.add('selected');
    selectedTradeItem = target;

    const fromPlayerIndex = parseInt(target.dataset.player);
    toPlayer1Btn.disabled = (fromPlayerIndex === 0);
    toPlayer2Btn.disabled = (fromPlayerIndex === 1);
  }

  function transferItem(toIndex) {
    if (!selectedTradeItem) return;

    const fromIndex = parseInt(selectedTradeItem.dataset.player);
    const itemName = selectedTradeItem.dataset.itemName;
    const isPotion = selectedTradeItem.dataset.isPotion === 'true';

    let fromPlayer, toPlayer;
    fromPlayer = players[fromIndex];
    toPlayer = players[toIndex];
    
    if(isPotion) {
        const itemToMove = fromPlayer.inventory.find(i => i.name === itemName);
        if(itemToMove){
            fromPlayer.inventory = fromPlayer.inventory.filter(i => i.name !== itemName);
            addItemToInventory(toPlayer, itemToMove);
        }
    } else { // Bonus item
        const itemIndex = fromPlayer.bonuses.findIndex(i => i.name === itemName);
        if(itemIndex > -1){
            const [itemToTransfer] = fromPlayer.bonuses.splice(itemIndex, 1);
            toPlayer.bonuses.push(itemToTransfer);
        }
    }
    
    updateTradeInventories();
    updateDiscoveriesLog();
  }
  
  player1InventoryList.addEventListener('click', handleTradeSelection);
  player2InventoryList.addEventListener('click', handleTradeSelection);
  toPlayer1Btn.addEventListener('click', () => { if(selectedTradeItem && selectedTradeItem.dataset.player === '1') transferItem(0); });
  toPlayer2Btn.addEventListener('click', () => { if(selectedTradeItem && selectedTradeItem.dataset.player === '0') transferItem(1); });
  closeTradeBtn.addEventListener('click', () => { tradeModal.style.display = 'none'; updateDiscoveriesLog(); });
  
  newGameBtn.addEventListener('click', promptForNewGame);
  saveGameBtn.addEventListener('click', saveGame);
  loadGameBtn.addEventListener('click', loadGame);
  cancelCharBtn.addEventListener('click', () => { charForm.style.display = 'none'; });
  closeBattlePotionSelectBtn.addEventListener('click', () => { battlePotionSelectModal.style.display = 'none'; });

  document.getElementById('playerCountConfirmBtn').addEventListener('click', () => {
    numPlayers = parseInt(document.getElementById('playerCountSelect').value);
    playerCountModal.style.display = 'none';
    creatingPlayerIndex = 0;
    showCharacterCreationForm();
  });
  
  startAdventureBtn.addEventListener('click', () => {
    const name = document.getElementById('charName').value.trim();
    const hpInput = document.getElementById('charHP').value;
    const charClass = document.getElementById('charClass').value;
    if (name && hpInput) {
        let hp = parseInt(hpInput);
        let energy = 0;
        let maxEnergy = 10;

        if (charClass === 'Guerriero') {
            hp += 10; 
            energy = 5;
            maxEnergy = 12;
        }

        players[creatingPlayerIndex] = {
            name, hp, maxHP: hp, class: charClass, attackDie: 10, defenseDie: 6, bonuses: [], inventory: [], hasSpecialSword: false, prisonersFreed: 0, enemiesDefeated: 0, energy, maxEnergy, isCursed: false, shadowSlayerBonus: 0, activeQuests: [], position: 1
        };
        creatingPlayerIndex++;
        if (creatingPlayerIndex < numPlayers) {
            showCharacterCreationForm();
        } else {
            startGame();
        }
    } else {
        alert('Inserisci un nome valido e i PF.');
    }
  });


  function init() {
      // Aggiunge gli event listener per sbloccare l'audio alla prima interazione
      window.addEventListener('click', initAudio, { once: true });
      window.addEventListener('touchstart', initAudio, { once: true });

      wireCellListeners();
      if (localStorage.getItem('dungeon72Save')) { loadGameBtn.style.display = 'block'; }
      window.addEventListener('resize', updateLayout);
      updateLayout();
      promptForNewGame();
  }

  init();
</script>
</body>
</html>
