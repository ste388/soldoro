<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dungeon 72 Celle - Chiamata del Soccorso</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
  <style>
    body { 
      background-image: url('https://i.imgur.com/HvMSTpG.jpg');
      background-size: cover;
      background-repeat: no-repeat;
      background-attachment: fixed;
      color:#e6e6e6; 
      font-family:Arial, sans-serif; 
      display:flex;
      justify-content: center;
      gap:20px; 
      padding:20px;
      padding-top: 100px;
      align-items: flex-start;
      box-sizing: border-box;
    }
    
    @keyframes screenShake {
      0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); }
    }

    .shake { animation: screenShake 0.5s; }

    #sticky-controls {
      position: fixed; top: 0; left: 0; width: 100%; background: #1a1915; border-radius: 0 0 10px 10px; z-index: 1000; padding: 10px; display: flex; gap: 14px; justify-content: center; align-items: center; box-shadow: 0 2px 12px rgba(0,0,0,0.40); transition: top 0.3s ease-in-out;
    }
    
    #left, #right { width:240px; display:flex; flex-direction:column; gap:10px; }
    #center-column { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 482px; }
    #board-wrapper { width: 100%; overflow-x: auto; -webkit-overflow-scrolling: touch; }
    #center { display: grid; grid-template-columns: repeat(9, 50px); gap: 4px; width: fit-content; background: rgba(20, 19, 15, 0.7); border-radius:10px; padding: 10px; box-shadow:inset 0 0 12px #000; }
    #right { align-items:center; }
    button { padding:10px 16px; border:none; border-radius:8px; background:#5a8c56; color:#fff; cursor:pointer; font-size:16px; width:100%; box-sizing: border-box; }
    #left button { min-width: 150px; }
    button:hover { background:#7cb673; }
    button:disabled { background:#555; cursor:not-allowed; }
    #sticky-controls button { width: auto; min-width: 120px; margin: 0; }
    #tradeBtn { background-color: #3b6b8c; }
    #tradeBtn:hover { background-color: #5a8ab0; }
    .intervention-btn { background-color: #c4832c; }
    .intervention-btn:hover { background-color: #e6a243; }
    .ignore-btn { background-color: #757575; }
    .ignore-btn:hover { background-color: #9e9e9e; }
    
    .cell { position: relative; width: 50px; height: 50px; border:2px solid #666; border-radius:6px; background:linear-gradient(145deg, rgba(74, 73, 63, 0.7), rgba(55, 55, 40, 0.7)); user-select:none; box-sizing: border-box; }
    .cell-content { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-weight: bold; color: #bfc5a7; }
    .visited { background: linear-gradient(145deg, #304d30, #223822); border-color: #658665; }
    .current-player-1 { background: linear-gradient(145deg, rgba(143, 173, 106, 0.8), rgba(110, 133, 71, 0.8)); border-color: #a0d535; color: #eff7d6; box-shadow: 0 0 10px #a0d535; }
    .current-player-2 { background: linear-gradient(145deg, rgba(106, 143, 173, 0.8), rgba(71, 110, 133, 0.8)); border-color: #35a0d5; color: #d6eaff; box-shadow: 0 0 10px #35a0d5; }
    .highlighted { border: 3px solid white !important; cursor: pointer; }
    
    .enemy-marker, .gas-marker { position:absolute; width:10px; height:10px; border-radius:50%; border:1px solid #fff; }
    .enemy-marker { top:3px; right:3px; background:red; }
    .gas-marker { bottom:3px; left:3px; background:#808080;}
    .hole-marker { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width: 40px; height: 40px; border-radius: 0; border: none; background-image: url('https://i.imgur.com/kG6JJlO.png'); background-size: contain; background-repeat: no-repeat; background-position: center; }

    .skull-marker, .prisoner-marker, .shadow-marker, .hero-marker, .item-marker { position:absolute; top:50%; left:50%; transform: translate(-50%, -50%); width: 80%; height: 80%; pointer-events:none; opacity: 0.9; }
    .item-marker { width: 70%; height: 70%; z-index: 6; }
    .skull-marker, .prisoner-marker { z-index: 5; }
    .hero-marker, .shadow-marker { z-index: 10; }
    .gem-door-marker { border: 3px solid deepskyblue !important; box-shadow: 0 0 15px deepskyblue; }
    
    #diceResult, #shadowDiceResult { width:80px; height:80px; font-size:48px; font-weight:bold; display:flex; align-items:center; justify-content:center; border:2px solid #a0d535; border-radius:10px; background:linear-gradient(145deg,#6e8547,#8fad6a); color:#d7f39b; }
    #shadowDiceResult { border-color: #993333; background: linear-gradient(145deg, #6b2a2a, #8f4b4b); color: #f3c2c2;}
    #main-message-display { min-height:24px; font-weight:bold; text-align:center; background-color: rgba(0,0,0,0.4); border-radius: 5px; padding: 5px; width:100%; box-sizing: border-box; visibility: hidden; }
    #shadowActionDisplay { display:none; min-height:24px; text-align:center; background-color: rgba(0,0,0,0.4); border-radius: 5px; padding: 5px; width:100%; box-sizing: border-box; margin-top: 10px; }
    
    #discoveriesLog { white-space: pre-line; background:rgba(58, 58, 43, 0.8); border-radius:8px; padding:10px; font-size:14px; min-height: 200px; width: 100%;}
    #playerInfo { text-align:center; padding: 5px 10px; border-radius:10px; min-width: 180px; font-weight: bold; }
    .player-1-info { border: 2px solid #a0d535; background: linear-gradient(145deg, #6e8547, #8fad6a); color: #eff7d6; }
    .player-2-info { border: 2px solid #35a0d5; background: linear-gradient(145deg, #476e85, #6a8fad); color: #d6eaff; }

    #charForm, #encounterModal, #messageModal, #initiativeModal, #potionDamageModal, #battlePotionSelectModal, #altarModal, #allyChoiceModal, #supportAttackModal, #tradeModal { display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background: #3a3a2b; padding:20px; border-radius:10px; box-shadow:0 0 15px #000; z-index:1001; text-align:center; width: 300px; }
    #charForm input, #charForm select { width: calc(100% - 16px); padding:8px; margin:8px 0; border:none; border-radius:6px; font-size:16px; }
    
    #battleModal { display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background: #3a3a2b; padding:20px; border-radius:10px; box-shadow:0 0 15px #000; z-index:1050; text-align:center; width: 900px; max-width: 95%; flex-direction: column; max-height: 90vh; overflow-y: auto; }
    #initiativeModal { z-index: 1051; }
    #potionDamageModal, #battlePotionSelectModal { z-index: 1060; }
    #altarModal { z-index: 1070; }
    #allyChoiceModal { z-index: 1080; }
    #supportAttackModal { z-index: 1090; }
    #tradeModal { z-index: 1100; width: 90%; max-width: 800px; display: flex; flex-direction: column; max-height: 80vh; overflow-y: auto; }
    #altarActions, #allyChoiceActions, #supportAttackActions { display: flex; gap: 10px; justify-content: center; margin-top: 15px; }

    #tradeContainer { display: flex; gap: 20px; text-align: left; flex-grow: 1; min-height: 0; }
    .trade-column { flex: 1; display: flex; flex-direction: column; min-height: 0; }
    .trade-column h3 { text-align: center; }
    .inventory-list { list-style: none; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; flex-grow: 1; overflow-y: auto; }
    .inventory-list li { padding: 8px; margin-bottom: 5px; background: #4f4f3e; border-radius: 5px; cursor: pointer; border: 2px solid transparent; }
    .inventory-list li:hover { background: #6a6a52; }
    .inventory-list li.selected { border-color: #ffeb3b; background: #7c7c5e; }
    #trade-actions { display: flex; flex-direction: column; justify-content: center; gap: 15px; }


    #combatants-container { display: flex; justify-content: space-between; gap: 15px; }
    #player-side, #enemy-side { flex: 1; display: flex; flex-direction: column; gap: 10px; }
    .battle-unit { margin: 0; border: 1px solid #555; padding: 10px; border-radius: 8px; }
    .battle-name { font-weight: bold; font-size: 20px; margin-bottom: 5px; color: #a0d535; }
    #allyJoinedIndicator { font-size: 14px; color: #fdd835; font-weight: bold; display:none; text-align: center; margin: 5px 0; }
    .battle-stats { font-size: 14px; color: #ccc; }
    .battle-pf, .battle-attack, .battle-defense { font-size: 16px; margin-bottom: 5px; }
    .battle-dice { font-size: 48px; font-weight: bold; min-height: 60px; display:flex; align-items:center; justify-content:center; }
    #battleResult { font-size: 18px; font-weight: bold; min-height: 24px; margin-top: 10px; transition: font-size 0.2s; line-height: 1.2; }
    #battleActionContainer, #initiativeActionContainer { display:flex; flex-direction:column; gap:10px; margin-top: 15px; }
    #specialAbilitiesContainer { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; justify-content: center;}
    #specialAbilitiesContainer button { font-size: 12px; padding: 8px 12px; flex-basis: calc(50% - 4px); }
    #initiativeResult { font-weight: bold; font-size: 18px; min-height: 24px; }
    #battleLog { min-height: 75px; padding: 10px; margin: 15px 0; background: rgba(0,0,0,0.3); border: 1px solid #444; border-radius: 8px; text-align: left; white-space: pre-line; font-size: 16px; line-height: 1.4; }

    #messageModal { background: linear-gradient(135deg, #4a3c26, #2d1f0f); border: 4px solid #8b5e3c; color: #f5deb3; font-family: 'MedievalSharp', cursive; font-size: 22px; }
    #messageModal.victory-modal .modal-content { display: flex; flex-direction: column; align-items: center; }
    #messageModal.victory-modal #messageModalText { font-size: 28px; margin-bottom: 5px; white-space: pre-line; }
    #messageModal.victory-modal #victorySubText { font-size: 18px; margin-bottom: 10px; white-space: pre-line; }
    #messageModal.victory-modal #prisonerStatusText { font-size: 16px; color: #d2b48c; }
    #messageModal button { font-family: 'MedievalSharp', cursive; font-size: 18px; margin-top: 20px; padding: 8px 25px; background-color: #8b5e3c; border-radius: 5px; border: 2px solid #5a3d2e; }
    #messageModal button:hover { background-color: #a3764a; }

    @media (max-width: 1024px) {
      body { flex-direction: column; padding: 10px; padding-top: 160px; gap: 10px; align-items: stretch; }
      #right { order: 1; align-items: stretch; }
      #center-column { order: 2; width: 100%; align-items: stretch; }
      #left { order: 3; }
      #left, #right { width: 100%; box-sizing: border-box; }
      #charForm, #encounterModal, #messageModal, #initiativeModal, #potionDamageModal, #battlePotionSelectModal, #altarModal, #allyChoiceModal, #supportAttackModal { width: 90%; }
      #tradeModal { flex-direction: column; }
      #tradeContainer { flex-direction: column; }
      #trade-actions { flex-direction: row; margin-top: 10px; }

      #battleModal { padding: 10px; }
      #combatants-container { flex-direction: column; }
      .battle-name { font-size: 18px; }
      .battle-pf, .battle-attack, .battle-defense { font-size: 14px; }
      .battle-dice { font-size: 40px; min-height: 50px; }
      
      #sticky-controls { flex-wrap: wrap; justify-content: space-around; }
      #sticky-controls button { flex-basis: 45%; min-width: auto; }
      #diceResult, #shadowDiceResult { flex-basis: 45%; }
      #playerInfo { flex-basis: 100%; margin-top: 5px; }
    }
  </style>
</head>
<body>

  <div id="sticky-controls">
      <div id="player-actions">
        <button id="diceRollBtn">Tira dado</button>
      </div>
      <div id="diceResult">-</div>
      <div id="playerInfo">Crea un personaggio</div>
      <div id="energyInfo" style="color: #4dd0e1; font-weight: bold;">Energia: <span id="energyValue">0</span></div>
  </div>

  <div id="left">
    <button id="saveGameBtn">Salva</button>
    <button id="loadGameBtn" style="display:none;">Carica Partita</button>
    <button id="newGameBtn">Nuova Partita</button>
  </div>
  
  <div id="center-column">
    <div id="main-message-display"></div>
    <div id="board-wrapper">
        <div id="center"></div>
    </div>
    <div id="discoveriesLog"></div>
  </div>

  <div id="right">
    <div id="shadowActionDisplay">
        <div id="shadowTurnName">Turno Ombre</div>
        <div id="shadowDiceResult">-</div>
    </div>
  </div>

  <div id="charForm">
    <div id="charFormTitle">Crea Personaggio</div>
    <div>Nome personaggio</div>
    <input type="text" id="charName" placeholder="Nome...">
    <div>PF iniziali</div>
    <input type="number" id="charHP" value="35" min="1">
    <div>Classe</div>
    <select id="charClass">
      <option value="Guerriero">Guerriero (+10 PF, +5 Energia)</option>
      <option value="Esploratore">Esploratore (-1 buchi, -2 rampicanti, rilancio)</option>
      <option value="Ladro">Ladro (Furtività e Fuga Migliorate)</option>
    </select>
    <div style="display:flex; gap:8px; margin-top:10px;">
      <button id="startAdventureBtn">Inizia Avventura</button>
      <button id="cancelCharBtn">Annulla</button>
    </div>
  </div>
  
  <div id="encounterModal">
    <p id="encounterMessage"></p>
    <div id="encounterModal-diceResult"></div>
    <div id="encounterActionBtns"></div>
  </div>

  <div id="initiativeModal">
    <p id="initiativeMessage"></p>
    <div class="battle-unit">
        <div id="initiativePlayerName" class="battle-name"></div>
        <div id="initiativePlayerStats" class="battle-stats"></div>
        <div id="initiativePlayerDice" class="battle-dice">-</div>
    </div>
    <div class="battle-unit">
        <div id="initiativeEnemyName" class="battle-name"></div>
        <div id="initiativeEnemyStats" class="battle-stats"></div>
        <div id="initiativeEnemyDice" class="battle-dice">-</div>
    </div>
    <p id="initiativeResult"></p>
    <div id="initiativeActionContainer">
        <button id="initiativeRollBtn">Lancia i dadi</button>
        <button id="usePotionInitiativeBtn">Usa Pozione</button>
    </div>
  </div>

 <div id="battleModal">
    <div id="combatants-container">
        <div id="player-side">
            <div class="battle-unit" id="main-player-battle-unit">
                <div id="battlePlayerName" class="battle-name"></div>
                <div id="battlePlayerPF" class="battle-pf"></div>
                <div id="battlePlayerAttack" class="battle-attack"></div>
                <div id="battlePlayerDefense" class="battle-defense"></div>
                <div id="battlePlayerDice" class="battle-dice">-</div>
            </div>
             <div class="battle-unit" id="ally-battle-unit" style="display:none;">
                <div id="battleAllyName" class="battle-name"></div>
                <div id="battleAllyPF" class="battle-pf"></div>
                <div id="battleAllyAttack" class="battle-attack"></div>
                <div id="battleAllyDefense" class="battle-defense"></div>
                 <div id="battleAllyDice" class="battle-dice">-</div>
            </div>
        </div>
        <div id="enemy-side">
            <div class="battle-unit">
                <div id="battleEnemyName" class="battle-name"></div>
                <div id="battleEnemyPF" class="battle-pf"></div>
                <div id="battleEnemyAttack" class="battle-attack"></div>
                <div id="battleEnemyDefense" class="battle-defense"></div>
                <div id="battleEnemyDice" class="battle-dice">-</div>
            </div>
        </div>
    </div>
    <div id="allyJoinedIndicator">Alleato in combattimento!</div>
    <div id="battleLog"></div>
    <div id="battleResult"></div>
    <div id="battleActionContainer"></div>
    <div id="specialAbilitiesContainer"></div>
  </div>

  <div id="messageModal">
      <div class="modal-content">
          <div id="messageModalText"></div>
          <div id="victorySubText"></div>
          <div id="prisonerStatusText"></div>
      </div>
      <button id="messageModalOkBtn">OK</button>
  </div>
  
  <div id="altarModal">
    <p id="altarMessage"></p>
    <div id="altarActions"></div>
  </div>
  
  <div id="allyChoiceModal">
    <p id="allyChoiceMessage"></p>
    <div id="allyChoiceActions"></div>
  </div>
  
  <div id="supportAttackModal">
      <p id="supportAttackMessage"></p>
      <div id="supportAttackDice" class="battle-dice">-</div>
      <div id="supportAttackActions"></div>
  </div>

  <div id="tradeModal">
    <h2>Scambio Oggetti</h2>
    <div id="tradeContainer">
      <div class="trade-column">
        <h3 id="tradePlayer1Name"></h3>
        <ul id="player1InventoryList" class="inventory-list"></ul>
      </div>
      <div id="trade-actions">
        <button id="toPlayer2Btn" disabled>&raquo;</button>
        <button id="toPlayer1Btn" disabled>&laquo;</button>
      </div>
      <div class="trade-column">
        <h3 id="tradePlayer2Name"></h3>
        <ul id="player2InventoryList" class="inventory-list"></ul>
      </div>
    </div>
    <button id="closeTradeBtn" style="margin-top: 20px;">Chiudi</button>
  </div>

  <div id="battlePotionSelectModal">
    <p>Seleziona una pozione da usare</p>
    <div id="battlePotionList"></div>
    <button id="closeBattlePotionSelectBtn" style="margin-top:15px;">Annulla</button>
  </div>

  <div id="potionDamageModal">
      <p id="potionDamageTitle"></p>
      <div id="potionDamageDice" style="font-size: 48px; font-weight: bold; min-height: 60px;">-</div>
      <button id="potionDamageRollBtn">Lancia</button>
  </div>


<script>
  // --- Gestione Suoni ---
  const sounds = {
    dice: new Audio('https://ste388.github.io/soldoro/fx/dadi.mp3'),
    hit: new Audio('https://ste388.github.io/soldoro/fx/colpoSpada.mp3'),
    powerhit: new Audio('https://ste388.github.io/soldoro/fx/colpo.mp3'),
    item: new Audio('https://ste388.github.io/soldoro/fx/trovare.mp3'),
    step: new Audio('https://ste388.github.io/soldoro/fx/passi.mp3'),
    shadow: new Audio('https://ste388.github.io/soldoro/fx/AppareOmbra.mp3'),
    battle: new Audio('https://ste388.github.io/soldoro/fx/battaglia.mp3'),
    parry: new Audio('https://ste388.github.io/soldoro/fx/parata.mp3'),
    background: new Audio('https://ste388.github.io/soldoro/fx/Sottofondo.mp3'),
    death: new Audio('https://ste388.github.io/soldoro/fx/morte.mp3'),
    hole: new Audio('https://ste388.github.io/soldoro/fx/buco.mp3'),
    gas: new Audio('https://ste388.github.io/soldoro/fx/gas.mp3'),
    vines: new Audio('https://ste388.github.io/soldoro/fx/rampicante.mp3'),
  };

  sounds.battle.loop = true;
  sounds.battle.volume = 0.3;
  sounds.background.loop = true;
  sounds.background.volume = 0.2;
  

  let audioInitialized = false;

  function initAudio() {
    if (audioInitialized) return;
    const promises = Object.values(sounds).map(sound => sound.play());
    
    Promise.all(promises).then(() => {
        Object.values(sounds).forEach(sound => {
            sound.pause();
            sound.currentTime = 0;
        });
        audioInitialized = true;
        playSound('background');
        console.log("Audio context unlocked and sounds ready.");
    }).catch(error => {
        console.warn("Could not unlock audio context automatically. Sounds will be played on demand.", error);
        audioInitialized = true;
        playSound('background');
    });
    
    window.removeEventListener('click', initAudio);
    window.removeEventListener('touchstart', initAudio);
  }

  function playSound(soundName) {
    if (!audioInitialized) return;
    const sound = sounds[soundName];
    if (sound) {
      if (!sound.loop) {
        sound.currentTime = 0;
      }
      const playPromise = sound.play();
      if (playPromise !== undefined) {
        playPromise.catch(error => console.warn(`Sound playback failed for ${soundName}: ${error.name}`));
      }
    }
  }

  function stopSound(soundName) {
      if (!audioInitialized) return;
      const sound = sounds[soundName];
      if (sound) {
        sound.pause();
        sound.currentTime = 0;
      }
  }

  // Elementi DOM
  const board = document.getElementById('center');
  const discoveriesLog = document.getElementById('discoveriesLog');
  const playerActions = document.getElementById('player-actions');
  const diceRes = document.getElementById('diceResult');
  const shadowActionDisplay = document.getElementById('shadowActionDisplay');
  const shadowTurnName = document.getElementById('shadowTurnName');
  const shadowDiceRes = document.getElementById('shadowDiceResult');
  const mainMessageDisplay = document.getElementById('main-message-display');
  const playerInfo = document.getElementById('playerInfo');
  const energyValue = document.getElementById('energyValue');
  const newGameBtn = document.getElementById('newGameBtn');
  const saveGameBtn = document.getElementById('saveGameBtn');
  const loadGameBtn = document.getElementById('loadGameBtn');
  const charForm = document.getElementById('charForm');
  const charFormTitle = document.getElementById('charFormTitle');
  const startAdventureBtn = document.getElementById('startAdventureBtn');
  const cancelCharBtn = document.getElementById('cancelCharBtn');
  const encounterModal = document.getElementById('encounterModal');
  const encounterMessage = document.getElementById('encounterMessage');
  const encounterDiceResult = document.getElementById('encounterModal-diceResult');
  const encounterActionBtns = document.getElementById('encounterActionBtns');
  const battleModal = document.getElementById('battleModal');
  const battlePlayerName = document.getElementById('battlePlayerName');
  const allyJoinedIndicator = document.getElementById('allyJoinedIndicator');
  const battlePlayerPF = document.getElementById('battlePlayerPF');
  const battlePlayerAttack = document.getElementById('battlePlayerAttack');
  const battlePlayerDefense = document.getElementById('battlePlayerDefense');
  const battlePlayerDice = document.getElementById('battlePlayerDice');
  const allyBattleUnit = document.getElementById('ally-battle-unit');
  const battleAllyName = document.getElementById('battleAllyName');
  const battleAllyPF = document.getElementById('battleAllyPF');
  const battleAllyAttack = document.getElementById('battleAllyAttack');
  const battleAllyDefense = document.getElementById('battleAllyDefense');
  const battleAllyDice = document.getElementById('battleAllyDice');
  const battleEnemyName = document.getElementById('battleEnemyName');
  const battleEnemyPF = document.getElementById('battleEnemyPF');
  const battleEnemyAttack = document.getElementById('battleEnemyAttack');
  const battleEnemyDefense = document.getElementById('battleEnemyDefense');
  const battleEnemyDice = document.getElementById('battleEnemyDice');
  const battleResult = document.getElementById('battleResult');
  const battleLog = document.getElementById('battleLog');
  const battleActionContainer = document.getElementById('battleActionContainer');
  const specialAbilitiesContainer = document.getElementById('specialAbilitiesContainer');
  const messageModal = document.getElementById('messageModal');
  const messageModalText = document.getElementById('messageModalText');
  const victorySubText = document.getElementById('victorySubText');
  const prisonerStatusText = document.getElementById('prisonerStatusText');
  const messageModalOkBtn = document.getElementById('messageModalOkBtn');
  const stickyControls = document.getElementById('sticky-controls');
  const initiativeModal = document.getElementById('initiativeModal');
  const initiativeMessage = document.getElementById('initiativeMessage');
  const initiativePlayerName = document.getElementById('initiativePlayerName');
  const initiativePlayerStats = document.getElementById('initiativePlayerStats');
  const initiativePlayerDice = document.getElementById('initiativePlayerDice');
  const initiativeEnemyName = document.getElementById('initiativeEnemyName');
  const initiativeEnemyStats = document.getElementById('initiativeEnemyStats');
  const initiativeEnemyDice = document.getElementById('initiativeEnemyDice');
  const initiativeResult = document.getElementById('initiativeResult');
  const initiativeRollBtn = document.getElementById('initiativeRollBtn');
  const usePotionInitiativeBtn = document.getElementById('usePotionInitiativeBtn');
  const battlePotionSelectModal = document.getElementById('battlePotionSelectModal');
  const battlePotionList = document.getElementById('battlePotionList');
  const closeBattlePotionSelectBtn = document.getElementById('closeBattlePotionSelectBtn');
  const potionDamageModal = document.getElementById('potionDamageModal');
  const potionDamageTitle = document.getElementById('potionDamageTitle');
  const potionDamageDice = document.getElementById('potionDamageDice');
  const potionDamageRollBtn = document.getElementById('potionDamageRollBtn');
  const altarModal = document.getElementById('altarModal');
  const altarMessage = document.getElementById('altarMessage');
  const altarActions = document.getElementById('altarActions');
  const allyChoiceModal = document.getElementById('allyChoiceModal');
  const allyChoiceMessage = document.getElementById('allyChoiceMessage');
  const allyChoiceActions = document.getElementById('allyChoiceActions');
  const supportAttackModal = document.getElementById('supportAttackModal');
  const supportAttackMessage = document.getElementById('supportAttackMessage');
  const supportAttackDice = document.getElementById('supportAttackDice');
  const supportAttackActions = document.getElementById('supportAttackActions');
  const tradeModal = document.getElementById('tradeModal');
  const player1InventoryList = document.getElementById('player1InventoryList');
  const player2InventoryList = document.getElementById('player2InventoryList');
  const toPlayer1Btn = document.getElementById('toPlayer1Btn');
  const toPlayer2Btn = document.getElementById('toPlayer2Btn');
  const closeTradeBtn = document.getElementById('closeTradeBtn');
  
  // Costanti di Gioco
  const COLS = 9, CELL_COUNT = 72, ENEMY_COUNT = 12, PRISONER_COUNT = 11, GAS_TRAP_COUNT = 2, HOLE_COUNT = 3, GAS_EFFECT_DURATION_CELLS = 5;
  const HOLE_IMAGE_URL = 'https://i.imgur.com/kG6JJlO.png';
  const ATTACK_BONUS_ITEMS = [ { name: "Elsa migliorata", iconUrl: "https://i.imgur.com/euz20nX.png" }, { name: "Guanti rinforzati", iconUrl: "https://i.imgur.com/aE8GVDY.png" }, { name: "Stivali", iconUrl: "https://i.imgur.com/BNy44sG.png" } ];
  const DEFENSE_BONUS_ITEMS = [ { name: "Scudo di ferro", iconUrl: "https://i.imgur.com/hF20xva.png" }, { name: "Elmo", iconUrl: "https://i.imgur.com/7Ur7oSX.png" }, { name: "Corazza", iconUrl: "https://i.imgur.com/vTBxHQI.png" } ];
  const POTIONS = [ { name: "Pozione Fuoco", type: "fire", iconUrl: "https://i.imgur.com/U4jwiij.png" }, { name: "Pozione Fuoco", type: "fire", iconUrl: "https://i.imgur.com/U4jwiij.png" }, { name: "Pozione Ghiaccio", type: "ice", iconUrl: "https://i.imgur.com/UqxFF43.png" }, { name: "Pozione Ghiaccio", type: "ice", iconUrl: "https://i.imgur.com/UqxFF43.png" }, { name: "Pozione (+5 PF)", value: 5, type: "heal", iconUrl: "https://i.imgur.com/OpZJJ1f.png" }, { name: "Pozione (+10 PF)", value: 10, type: "heal", iconUrl: "https://i.imgur.com/OpZJJ1f.png" }, { name: "Pozione (+15 PF)", value: 15, type: "heal", iconUrl: "https://i.imgur.com/OpZJJ1f.png" } ];
  const GEMS = [ { name: "Gemma Blu", iconUrl: "https://i.imgur.com/cD8wDec.png" }, { name: "Gemma Verde", iconUrl: "https://i.imgur.com/h7dcivA.png" }, { name: "Gemma Viola", iconUrl: "https://i.imgur.com/yWygx8z.png" } ];
  const GEM_DOOR = { name: "Porta di Gemme", iconUrl: "https://i.imgur.com/2u6BWSv.png" };
  const ALTARS = [ { name: "Altare Sacrificale", type: 'sacrificial', iconUrl: "https://i.imgur.com/zR75xod.png" }, { name: "Altare della Maledizione", type: 'curse', iconUrl: "https://i.imgur.com/0XEOJdW.png" }, { name: "Altare della Purificazione", type: 'purification', iconUrl: "https://i.imgur.com/SNImGq0.png" } ];
  const SHADOW_SPAWNS = [ { name: "Ombra", hp: 10, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 1, iconUrl: "https://i.imgur.com/sgLJSln.png", spawnTurn: 10 }, { name: "Ombra Paurosa", hp: 15, attackDie: 10, attackBonus: 1, defenseDie: 8, defenseBonus: 0, iconUrl: "https://i.imgur.com/grZ66Ex.png", spawnTurn: 30 }, { name: "Ombra Cattiva", hp: 20, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 1, iconUrl: "https://i.imgur.com/Jo45qDz.png", spawnTurn: 45 }, { name: "Ombra Cattivissima", hp: 25, attackDie: 10, attackBonus: 1, defenseDie: 8, defenseBonus: 1, iconUrl: "https://i.imgur.com/rJg2v1t.png", spawnTurn: 55 } ];
  const ENEMY_DEFINITIONS = [ { name: "Orchetto", hp: 10, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 0 }, { name: "Orchetto", hp: 10, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 0 }, { name: "Orchetto", hp: 10, attackDie: 10, attackBonus: 0, defenseDie: 8, defenseBonus: 0 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 1 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 1, defenseDie: 6, defenseBonus: 0 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 0, defenseDie: 8, defenseBonus: 0 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 1, defenseDie: 8, defenseBonus: 0 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 1 }, { name: "Orco", hp: 12, attackDie: 10, attackBonus: 1, defenseDie: 6, defenseBonus: 1 }, { name: "Troll", hp: 15, attackDie: 10, attackBonus: 0, defenseDie: 8, defenseBonus: 0 }, { name: "Troll", hp: 15, attackDie: 10, attackBonus: 1, defenseDie: 8, defenseBonus: 0 }, { name: "Troll", hp: 15, attackDie: 10, attackBonus: 0, defenseDie: 6, defenseBonus: 1 }, ];
  const NEW_SKULL_ICON_URL = 'https://i.imgur.com/g9mN0pU.jpg';
  const PRISONER_ICON_URL = 'https://i.imgur.com/XW3fJxc.jpg';
  const CLASS_ICONS = { Guerriero: 'https://i.imgur.com/IcEVhov.png', Esploratore: 'https://i.imgur.com/61wtgJ1.png', Ladro: 'https://i.imgur.com/eY1Q0b5.png' };

  // ---- STATO DEL GIOCO ----
  let players = [];
  let currentPlayerIndex = 0;
  let numPlayers = 1;
  let creatingPlayerIndex = 0;
  
  let enemiesDefeatedCount, discoveryCounter;
  let visitedCells, enemyMap, bonusMap, potionMap, prisonerMap, altarMap, gasTrapPositions, gasActivatedPositions, holePositions, shadows, spawnedShadows;
  let gasEffect = { active: false, newCellsVisited: 0 };
  let prisonerQuests;
  let messageQueue = [];
  let activeBattleState = null;
  let activeAbility = null;
  let selectedTradeItem = null;
  
  // ---- FUNZIONI PRINCIPALI ----
  function triggerScreenShake() { document.body.classList.add('shake'); setTimeout(() => document.body.classList.remove('shake'), 500); }
  
  function updateEnergyUI() {
      if (players.length === 0) return;
      const character = players[currentPlayerIndex];
      if (!character) return;
      const cost = character.class === 'Guerriero' ? 4 : 5;
      energyValue.textContent = character.energy;
      
      const powerStrikeBtn = document.getElementById('powerStrikeBtn');
      if (powerStrikeBtn) powerStrikeBtn.disabled = character.energy < cost;

      const doubleAttackBtn = document.getElementById('doubleAttackBtn');
      if (doubleAttackBtn) doubleAttackBtn.disabled = character.energy < cost;
  }

  function gainEnergy(amount) {
      const character = players[currentPlayerIndex];
      if (!character) return;
      character.energy = Math.min(character.energy + amount, character.maxEnergy);
      updateEnergyUI();
  }

  function getAttackBonus(player, isAgainstShadow = false) {
      if (!player) return 0;
      const attackItemNames = ATTACK_BONUS_ITEMS.map(item => item.name);
      let bonus = player.bonuses.filter(b => attackItemNames.includes(b.name)).length;
      if (gasEffect.active && players.indexOf(player) === currentPlayerIndex) bonus -= 1;
      if (player.isCursed) bonus -= 2;
      if (isAgainstShadow && player.shadowSlayerBonus) bonus += player.shadowSlayerBonus;
      return bonus;
  }

  function getDefenseBonus(player) {
      if (!player) return 0;
      const defenseItemNames = DEFENSE_BONUS_ITEMS.map(item => item.name);
      return player.bonuses.filter(b => defenseItemNames.includes(b.name)).length;
  }
  
  function addSkullMarker(cell) { const contentDiv = cell.querySelector('.cell-content'); if (!contentDiv) return; contentDiv.innerHTML = ''; const img = document.createElement('img'); img.src = NEW_SKULL_ICON_URL; img.className = 'skull-marker'; contentDiv.appendChild(img); }
  function addPrisonerMarker(cell) { const contentDiv = cell.querySelector('.cell-content'); if (!contentDiv) return; contentDiv.innerHTML = ''; const img = document.createElement('img'); img.src = PRISONER_ICON_URL; img.className = 'prisoner-marker'; contentDiv.appendChild(img); }
  function addHoleMarker(cell) { const contentDiv = cell.querySelector('.cell-content'); if (!contentDiv) return; contentDiv.innerHTML = ''; const img = document.createElement('div'); img.className = 'hole-marker'; contentDiv.appendChild(img); }

  function removeGems(player) {
      const gemNames = new Set(GEMS.map(g => g.name));
      player.bonuses = player.bonuses.filter(bonus => !gemNames.has(bonus.name));
  }

  function updateDiscoveriesLog() {
      const lines = [];
      lines.push(`Celle esplorate: ${visitedCells ? visitedCells.size : 0}`);
      lines.push(`Nemici Uccisi: ${enemiesDefeatedCount} / 12`);
      lines.push('');
      players.forEach((player, idx) => {
          lines.push(`--- Giocatore ${idx + 1}: ${player.name} ---`);
          lines.push(`PF: ${Math.max(0, player.hp)} / ${player.maxHP}`);
          lines.push(`Energia: ${player.energy} / ${player.maxEnergy}`);
          const attackItemNames = ATTACK_BONUS_ITEMS.map(item => item.name);
          const attackBonuses = player.bonuses.filter(b => attackItemNames.includes(b.name));
          if (attackBonuses.length > 0) { lines.push('Bonus Attacco:'); attackBonuses.forEach(b => lines.push(`- ${b.name} (+1)`)); }
          const defenseItemNames = DEFENSE_BONUS_ITEMS.map(item => item.name);
          const defenseBonuses = player.bonuses.filter(b => defenseItemNames.includes(b.name));
          if (defenseBonuses.length > 0) { lines.push('Bonus Difesa:'); defenseBonuses.forEach(b => lines.push(`- ${b.name} (+1)`)); }
          const potionsInInventory = player.inventory;
          if (potionsInInventory.length > 0) { lines.push('Pozioni:'); potionsInInventory.forEach(p => lines.push(`- ${p.name}`)); }
          const collectedGemNames = new Set(player.bonuses.map(b => b.name));
          const gemsToShow = GEMS.filter(g => collectedGemNames.has(g.name));
          if (gemsToShow.length > 0) { lines.push('Gemme:'); gemsToShow.forEach(gem => lines.push(`- ${gem.name}`)); }
          lines.push('Effetti:');
          let hasEffects = false;
          if (idx === currentPlayerIndex && gasEffect.active) { const remainingCells = GAS_EFFECT_DURATION_CELLS - gasEffect.newCellsVisited; lines.push(`- Gas Debolezza (-1 Atk per ${remainingCells} celle)`); hasEffects = true; }
          if (player.isCursed) { lines.push(`- Maledizione (-2 Attacco)`); hasEffects = true; }
          if (player.shadowSlayerBonus > 0) { lines.push(`- Benedizione (+${player.shadowSlayerBonus} Attacco vs Ombre)`); hasEffects = true; }
          if (!hasEffects) { lines.push('Nessuno'); }
          lines.push(`Prigionieri Liberati: ${player.prisonersFreed}`);
          lines.push('');
      });
      discoveriesLog.textContent = lines.join('\n');
  }

  function placeDiscoveries() {
      enemyMap = {}; bonusMap = {}; potionMap = {}; prisonerMap = {}; altarMap = {}; gasTrapPositions = new Set(); gasActivatedPositions = new Set(); holePositions = new Set(); shadows = []; spawnedShadows = new Set(); prisonerQuests = { quests: {} };
      let availableCells = Array.from({length: CELL_COUNT}, (_, i) => i + 1).filter(cellNum => cellNum !== 1);
      for (let i = availableCells.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [availableCells[i], availableCells[j]] = [availableCells[j], availableCells[i]]; }
      for(let i=0; i<HOLE_COUNT; i++) { if(availableCells.length > 0) holePositions.add(availableCells.pop()); }
      for(let i = 0; i < ENEMY_COUNT; i++) { if(availableCells.length > 0) enemyMap[availableCells.pop()] = { name: 'Nemico Casuale' }; }
      ATTACK_BONUS_ITEMS.forEach(item => { if(availableCells.length > 0) bonusMap[availableCells.pop()] = item; });
      DEFENSE_BONUS_ITEMS.forEach(item => { if(availableCells.length > 0) bonusMap[availableCells.pop()] = item; });
      POTIONS.forEach(potion => { if(availableCells.length > 0) potionMap[availableCells.pop()] = potion; });
      GEMS.forEach(gem => { if(availableCells.length > 0) bonusMap[availableCells.pop()] = gem; });
      ALTARS.forEach(altar => { if(availableCells.length > 0) altarMap[availableCells.pop()] = altar; });
      if(availableCells.length > 0) bonusMap[availableCells.pop()] = GEM_DOOR;
      let prisonerCells = [];
      for (let i = 0; i < PRISONER_COUNT; i++) { if (availableCells.length > 0) { const cell = availableCells.pop(); prisonerMap[cell] = true; prisonerCells.push(cell); } }
      for (let i = 0; i < GAS_TRAP_COUNT; i++) { if (availableCells.length > 0) gasTrapPositions.add(availableCells.pop()); }
      if (prisonerCells.length >= 6) {
          for (let i = prisonerCells.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [prisonerCells[i], prisonerCells[j]] = [prisonerCells[j], prisonerCells[i]]; }
          let questGiver1 = prisonerCells.pop(); let target1 = prisonerCells.find(c => c > 36);
          if (target1) { prisonerCells.splice(prisonerCells.indexOf(target1), 1); prisonerQuests.quests[questGiver1] = { type: 'brother', targetCell: target1, reward: {name: 'Pozione (+5 PF)', value: 5, type: 'heal'}, status: 'inactive' }; prisonerQuests.quests[target1] = { type: 'brother-target', giver: questGiver1 }; }
          let questGiver2 = prisonerCells.pop(); let target2 = prisonerCells.find(c => c < 36);
          if (target2) { prisonerCells.splice(prisonerCells.indexOf(target2), 1); prisonerQuests.quests[questGiver2] = { type: 'father', targetCell: target2, reward: {name: 'Pozione Fuoco', type: 'fire'}, status: 'inactive' }; prisonerQuests.quests[target2] = { type: 'father-target', giver: questGiver2 }; }
          let questGiver3 = prisonerCells.pop(); let target3 = prisonerCells.pop();
          if (questGiver3 && target3) { prisonerQuests.quests[questGiver3] = { type: 'mother', targetCell: target3, reward: {name: 'Fiala di Energia', type: 'energy', iconUrl: 'https://i.imgur.com/vjgNL2x.png'}, status: 'inactive' }; prisonerQuests.quests[target3] = { type: 'mother-target', giver: questGiver3 }; }
      }
  }
  
  function placeBoss() {
      const allCellNumbers = Array.from({length: CELL_COUNT}, (_, i) => i + 1);
      const occupiedCells = new Set(Array.from(visitedCells.keys()).map(Number));
      Object.keys(enemyMap).forEach(k => occupiedCells.add(Number(k))); Object.keys(bonusMap).forEach(k => occupiedCells.add(Number(k))); Object.keys(potionMap).forEach(k => occupiedCells.add(Number(k))); Object.keys(prisonerMap).forEach(k => occupiedCells.add(Number(k))); Object.keys(altarMap).forEach(k => occupiedCells.add(Number(k))); holePositions.forEach(k => occupiedCells.add(Number(k)));
      const freeCells = allCellNumbers.filter(num => !occupiedCells.has(num));
      if (freeCells.length > 0) { const bossCellNum = freeCells[Math.floor(Math.random() * freeCells.length)]; enemyMap[bossCellNum] = { name: 'Boss Finale', isBoss: true }; messageQueue.push("Un'oscura presenza è apparsa nel dungeon..."); }
      else { messageQueue.push({endGame: true, title: "Dungeon non depurato!", subtitle: "Il Dungeon non è stato completamente depurato, prova ancora, avrai più fortuna.."}); }
  }

  function buildBoard() {
      board.innerHTML = '';
      for (let i = 1; i <= CELL_COUNT; i++) {
          const r = Math.floor((i - 1) / COLS); const c = (i - 1) % COLS;
          const cellDiv = document.createElement('div'); cellDiv.className = 'cell'; cellDiv.dataset.cellNumber = i; cellDiv.dataset.row = r; cellDiv.dataset.col = c;
          const content = document.createElement('div'); content.className = 'cell-content'; cellDiv.appendChild(content);
          if (visitedCells && visitedCells.has(String(i))) {
              cellDiv.classList.add('visited'); const info = visitedCells.get(String(i)); content.innerHTML = '';
              if (info.defeated) addSkullMarker(cellDiv);
              else if (info.prisonerFreed) addPrisonerMarker(cellDiv);
              else if (holePositions.has(i)) addHoleMarker(cellDiv);
              else if (info.altar) { const img = document.createElement('img'); img.src = info.altar.iconUrl; img.className = 'item-marker'; content.appendChild(img); }
              else if (info.bonus && info.bonus.iconUrl) { const img = document.createElement('img'); img.src = info.bonus.iconUrl; img.className = 'item-marker'; content.appendChild(img); }
              else if (info.potion && info.potion.iconUrl) { const img = document.createElement('img'); img.src = info.potion.iconUrl; img.className = 'item-marker'; content.appendChild(img); }
              else { content.textContent = i; }
              if (info.enemy && !info.defeated) content.appendChild(Object.assign(document.createElement('div'), { className: 'enemy-marker' }));
              if (info.bonus && info.bonus.name === GEM_DOOR.name) cellDiv.classList.add('gem-door-marker');
          } else { content.textContent = i; }
          const shadowHere = shadows.find(s => s.position === i && s.hp > 0);
          if (shadowHere) { const img = document.createElement('img'); img.src = shadowHere.iconUrl; img.className = 'shadow-marker'; content.appendChild(img); }
          players.forEach((p, index) => { if (p.position === i && (!activeBattleState || p.position !== activeBattleState.battleCellNum)) { const img = document.createElement('img'); img.src = CLASS_ICONS[p.class]; img.className = 'hero-marker'; content.appendChild(img); if (index === currentPlayerIndex && !activeBattleState) { cellDiv.classList.add(`current-player-${index + 1}`); } } });
          if (gasActivatedPositions.has(i)) content.appendChild(Object.assign(document.createElement('div'), { className: 'gas-marker' }));
          board.appendChild(cellDiv);
      }
  }
  
  function getValidMoves(steps) {
      const character = players[currentPlayerIndex];
      if (!character) return [];
      const startCell = board.querySelector(`[data-cell-number="${character.position}"]`);
      if (!startCell) return [];
      const startRow = startCell.dataset.row, startCol = startCell.dataset.col;
      return [...board.querySelectorAll('.cell')].filter(cell => {
          if (cell === startCell) return false;
          const r = cell.dataset.row, c = cell.dataset.col;
          const dr = Math.abs(r - startRow), dc = Math.abs(c - startCol);
          return Math.max(dr, dc) === steps;
      });
  }
  
  function clearHighlights() { board.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted')); }

  function processMessageQueue(onComplete) {
      messageModal.classList.remove('victory-modal'); victorySubText.textContent = ''; prisonerStatusText.textContent = '';
      if (messageQueue.length > 0) {
          const message = messageQueue.shift();
          if (typeof message === 'object' && message.victory) { 
              messageModal.classList.add('victory-modal'); 
              messageModalText.textContent = message.title; 
              victorySubText.textContent = message.subtitle; 
              prisonerStatusText.textContent = message.prisonerStatus; 
          } else if (typeof message === 'object' && message.endGame) { 
              messageModal.classList.add('victory-modal'); 
              messageModalText.textContent = message.title; 
              victorySubText.textContent = message.subtitle; 
              messageModal.style.display = 'block'; 
              playerActions.innerHTML = ''; 
              messageModalOkBtn.onclick = () => { 
                  messageModal.style.display = 'none'; 
                  promptForNewGame(); 
              }; 
              return; 
          } else { 
              messageModalText.innerHTML = message; 
          }
          messageModal.style.display = 'block';
          messageModalOkBtn.onclick = () => {
              messageModal.style.display = 'none';
              processMessageQueue(onComplete);
          };
          messageModalOkBtn.focus();
      } else {
          messageModal.style.display = 'none';
          if (onComplete) onComplete();
      }
  }
  
  function setMainMessage(text, color = '#ffcc00') { mainMessageDisplay.textContent = text; mainMessageDisplay.style.color = color; mainMessageDisplay.style.visibility = text ? 'visible' : 'hidden'; }
  function resetMessages() { setMainMessage(''); }
  
  function setBattleMode(isBattle) {
      if (isBattle) {
          stickyControls.style.top = '-200px';
          sounds.background.pause();
          playSound('battle');
      } else {
          activeBattleState = null;
          stickyControls.style.top = '0';
          stopSound('battle');
          playSound('background');
      }
      buildBoard();
  }

  function findPath(start, end) {
      let queue = [[start]]; let visited = new Set([start]);
      while(queue.length > 0) {
          let path = queue.shift(); let pos = path[path.length - 1]; if(pos === end) return path;
          let neighbors = [pos - 1, pos + 1, pos - COLS, pos + COLS, pos-COLS-1, pos-COLS+1, pos+COLS-1, pos+COLS+1].filter(n => {
              if (n < 1 || n > CELL_COUNT || visited.has(n)) return false;
              const r1 = Math.floor((pos - 1) / COLS), c1 = (pos - 1) % COLS;
              const r2 = Math.floor((n - 1) / COLS), c2 = (n - 1) % COLS;
              return Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1;
          });
          neighbors.sort((a,b) => {
              const distA = Math.abs(Math.floor((a-1)/COLS) - Math.floor((end-1)/COLS)) + Math.abs(((a-1)%COLS) - ((end-1)%COLS));
              const distB = Math.abs(Math.floor((b-1)/COLS) - Math.floor((end-1)/COLS)) + Math.abs(((b-1)%COLS) - ((end-1)%COLS));
              return distA - distB;
          });
          for (const neighbor of neighbors) { if (!visited.has(neighbor)) { visited.add(neighbor); let newPath = [...path, neighbor]; queue.push(newPath); } }
      }
      return null;
  }
  
  async function animateAndSetCurrent(destinationCell) {
      playerActions.innerHTML = '<button id="diceRollBtn" disabled>Tira dado</button>';
      clearHighlights(); diceRes.textContent = '-'; const character = players[currentPlayerIndex];
      const startNum = character.position; const endNum = parseInt(destinationCell.dataset.cellNumber); const path = findPath(startNum, endNum);
      if (!path || path.length <= 1) { character.position = endNum; processCellLogic(destinationCell); return; }
      for (let i = 1; i < path.length; i++) { await new Promise(resolve => setTimeout(resolve, 150)); playSound('step'); character.position = path[i]; buildBoard(); }
      processCellLogic(destinationCell);
  }

  function processCellLogic(cell) {
    const character = players[currentPlayerIndex];
    const cellNum = parseInt(cell.dataset.cellNumber);
    character.position = cellNum;
    resetMessages();
    let subsequentAction;

    const isNewVisit = !visitedCells.has(String(cellNum));
    if (isNewVisit) {
        discoveryCounter++;
        visitedCells.set(String(cellNum), { enemy: null, bonus: null, potion: null, altar: null, prisonerFreed: false, collected: false, defeated: false, hp: 0, discoveryOrder: discoveryCounter });
        
        const info = visitedCells.get(String(cellNum));
        info.enemy = enemyMap[cellNum] ? { ...enemyMap[cellNum] } : null;
        info.bonus = bonusMap[cellNum] ? { ...bonusMap[cellNum] } : null;
        info.potion = potionMap[cellNum] ? { ...potionMap[cellNum] } : null;
        info.altar = altarMap[cellNum] ? { ...altarMap[cellNum] } : null;

        if (holePositions.has(cellNum)) { const damage = character.class === 'Esploratore' ? 2 : 3; messageQueue.push(`Ti sloghi una caviglia in un buco! Perdi ${damage} PF.`); playSound('hole'); triggerScreenShake(); addHoleMarker(cell); character.hp -= damage; if (character.hp <= 0) { subsequentAction = () => handleGameOver("per una caviglia slogata", character); processMessageQueue(subsequentAction); return; } }
        if (visitedCells.size > 0 && visitedCells.size % 20 === 0) gainEnergy(1);
        if (gasEffect.active) { gasEffect.newCellsVisited++; if (gasEffect.newCellsVisited >= GAS_EFFECT_DURATION_CELLS) { gasEffect.active = false; gasEffect.newCellsVisited = 0; messageQueue.push("L'effetto del gas di debolezza è svanito!"); } }
        if (visitedCells.size > 0 && visitedCells.size % 7 === 0) { character.hp = Math.min(character.hp + 3, character.maxHP); messageQueue.push("Il riposo ti ha fatto guadagnare 3 PF."); }
        if (gasTrapPositions.has(cellNum) && !gasActivatedPositions.has(cellNum)) { playSound('gas'); messageQueue.push(`Sei finito in una trappola a gas! Attacco -1 finché non scopri ${GAS_EFFECT_DURATION_CELLS} nuove celle.`); gasEffect.active = true; gasEffect.newCellsVisited = 0; gasActivatedPositions.add(cellNum); }
        if (info.bonus) {
            if (info.bonus.name === GEM_DOOR.name) {
                messageQueue.push("Trovi una porta incastonata di gemme. È sigillata.");
            } else if (!character.bonuses.some(b => b.name === info.bonus.name)) {
                character.bonuses.push(info.bonus);
                playSound('item');
                const gemNames = GEMS.map(g => g.name);
                if (gemNames.includes(info.bonus.name)) {
                    messageQueue.push(`Hai trovato una ${info.bonus.name}!`);
                } else {
                    messageQueue.push(`Hai trovato ${info.bonus.name}!`);
                }
            }
        }
        if (info.potion) { if (!info.collected) { character.inventory.push(info.potion); playSound('item'); info.collected = true; messageQueue.push(`Hai trovato ${info.potion.name}.`); } }
        if (prisonerMap[cellNum]) { if(!visitedCells.get(String(cellNum)).prisonerFreed) { character.prisonersFreed++; info.prisonerFreed = true; messageQueue.push('Hai liberato un prigioniero!'); handlePrisonerQuest(cellNum); }}
    } else {
        const info = visitedCells.get(String(cellNum));
        if (info && info.bonus && info.bonus.name === GEM_DOOR.name) {
            const hasAllGems = GEMS.every(gem => character.bonuses.some(b => b.name === gem.name));
            if (hasAllGems && !character.hasSpecialSword) {
                character.hasSpecialSword = true;
                playSound('item');
                messageQueue.push("Usi le gemme... La Porta si apre! All'interno trovi una Spada Speciale (1D12+1)!");
                removeGems(character);
            }
        }
    }


    if (numPlayers > 1) {
      const otherPlayerIndex = (currentPlayerIndex + 1) % 2;
      if (players.length > 1 && players[otherPlayerIndex].position === cellNum) {
          showTradeButton();
      } else {
          hideTradeButton();
      }
    }

    const currentCellInfo = visitedCells.get(String(cellNum)) || {};
    if (currentCellInfo.altar) {
      subsequentAction = () => handleAltar(currentCellInfo.altar);
    } else {
      const shadowAtLocation = shadows.find(s => s.position === cellNum && s.hp > 0);
      if (shadowAtLocation) {
        subsequentAction = () => startBattle(shadowAtLocation);
      } else if (currentCellInfo && currentCellInfo.enemy && !currentCellInfo.defeated) {
        subsequentAction = () => handleEncounter(currentCellInfo.enemy);
      } else {
        if (currentCellInfo && currentCellInfo.enemy && currentCellInfo.defeated) setMainMessage('Qui giace un nemico sconfitto.', '#a9a9a9'); 
        else if (isNewVisit && cellNum !== 1) setMainMessage('Procedi tranquillo', 'lightgreen'); 
        else if (!isNewVisit) setMainMessage('Cella già visitata', '#ffffff');
        subsequentAction = () => endTurnSequence();
      }
    }
    
    updatePlayerInfo(); updateDiscoveriesLog(); buildBoard();
    processMessageQueue(subsequentAction);
  }

  function handleAltar(altar) {
    const character = players[currentPlayerIndex];
    if (altar.type === 'sacrificial') {
        altarModal.style.display = 'block';
        altarMessage.textContent = "Vedi un altare. Puoi sacrificare 4 PF per ricevere una benedizione (+2 Attacco vs Ombre).";
        altarActions.innerHTML = '';
        const yesBtn = document.createElement('button');
        yesBtn.textContent = 'Sì';
        yesBtn.onclick = () => {
            playSound('hit');
            character.hp -= 4;
            character.shadowSlayerBonus = 2;
            messageQueue.push("Hai ricevuto una benedizione! Ottieni +2 agli attacchi contro tutte le Ombre.");
            altarModal.style.display = 'none';
            processMessageQueue(() => {
                if (character.hp <= 0) handleGameOver("sacrificandosi all'altare", character);
                else endTurnSequence();
            });
        };
        const noBtn = document.createElement('button');
        noBtn.textContent = 'No';
        noBtn.onclick = () => {
            altarModal.style.display = 'none';
            endTurnSequence();
        };
        altarActions.appendChild(yesBtn);
        altarActions.appendChild(noBtn);
    } else if (altar.type === 'curse') {
        if (!character.isCursed) {
            character.isCursed = true;
            messageQueue.push("Sei stato maledetto! Hai -2 ai tuoi attacchi. Trova l'altare della purificazione per rimuovere la maledizione.");
        } else {
            messageQueue.push("Senti un'aura maligna, ma sei già maledetto.");
        }
        processMessageQueue(endTurnSequence);
    } else if (altar.type === 'purification') {
        if (character.isCursed) {
            character.isCursed = false;
            messageQueue.push("L'aura benefica dell'altare ti purifica! La maledizione è stata rimossa.");
        } else {
            messageQueue.push("Senti un'aura di pace emanare dall'altare, ma non hai maledizioni da rimuovere.");
        }
        processMessageQueue(endTurnSequence);
    }
}

  function handlePrisonerQuest(cellNum) {
    const character = players[currentPlayerIndex];
    const quest = prisonerQuests.quests[cellNum];
    if (!quest) return;

    if (quest.status === 'inactive') {
        quest.status = 'active';
        character.activeQuests = character.activeQuests || [];
        character.activeQuests.push(cellNum);

        let familyMember = '', locationInfo = '', possessive = '', pronoun = '';

        if (quest.type === 'brother') {
            familyMember = 'fratello';
            locationInfo = 'nella parte nord';
            possessive = 'Mio';
            pronoun = 'lui';
        } else if (quest.type === 'father') {
            familyMember = 'padre';
            locationInfo = 'nella parte sud';
            possessive = 'Mio';
            pronoun = 'lui';
        } else if (quest.type === 'mother') {
            familyMember = 'madre';
            locationInfo = 'qui vicino';
            possessive = 'Mia';
            pronoun = 'lei';
        }
        
        const targetCellInfo = visitedCells.get(String(quest.targetCell));
        if (targetCellInfo && targetCellInfo.prisonerFreed) {
            quest.status = 'completed';
            character.inventory.push(quest.reward);
            playSound('item');
            messageQueue.push(`"Grazie!" dice il prigioniero. "Ho saputo che ${possessive.toLowerCase()} ${familyMember} è già in salvo! Prendi questa ricompensa per il tuo valore!"`);
            messageQueue.push(`Hai ottenuto: ${quest.reward.name}!`);
        } else if (familyMember) {
            messageQueue.push(`Grazie per avermi liberato! ${possessive} ${familyMember} è ${locationInfo} del dungeon (cella ${quest.targetCell}). Se liberi anche ${pronoun}, ti ricompenserò!`);
        }
    } else if (quest.type.includes('-target')) {
        const giverQuest = prisonerQuests.quests[quest.giver];
        if (giverQuest && giverQuest.status === 'active') {
            giverQuest.status = 'completed';
            
            let questOriginator = null;
            for(const p of players){
                if(p.activeQuests && p.activeQuests.includes(quest.giver)){
                    questOriginator = p;
                    p.activeQuests.splice(p.activeQuests.indexOf(quest.giver), 1);
                    break;
                }
            }

            const rewardRecipient = questOriginator || character;
            rewardRecipient.inventory.push(giverQuest.reward);
            playSound('item');
            messageQueue.push(`Il prigioniero che hai appena liberato è il parente che si stava cercando! Per ringraziarti, viene consegnata la ricompensa promessa a ${rewardRecipient.name}: ${giverQuest.reward.name}!`);
        }
    }
}
  
  async function endTurnSequence() {
      if (activeBattleState) return;
      hideTradeButton();
      let battleStarted = false;
      const exploredCount = visitedCells.size;
      for (const spawn of SHADOW_SPAWNS) {
          if (exploredCount >= spawn.spawnTurn && !spawnedShadows.has(spawn.name)) {
              spawnedShadows.add(spawn.name);
              playSound('shadow');
              let freeCells = Array.from({length: CELL_COUNT}, (_, i) => i + 1).filter(c => c !== players[currentPlayerIndex].position && !shadows.some(s => s.position === c));
              if(freeCells.length > 0) {
                  const pos = freeCells[Math.floor(Math.random() * freeCells.length)];
                  shadows.push({ ...spawn, hp: spawn.hp, startHP: spawn.hp, position: pos, isShadow: true });
                  messageQueue.push(`${spawn.name} è apparsa nel dungeon!`);
                  await new Promise(resolve => processMessageQueue(resolve));
                  buildBoard();
              }
          }
      }

      if (shadows.some(s => s.hp > 0)) {
          shadowActionDisplay.style.display = 'block';
          for (const shadow of shadows) {
              if (shadow.hp > 0) {
                  await new Promise(resolve => setTimeout(resolve, 1000));
                  shadowTurnName.textContent = shadow.name;
                  const moveRoll = Math.floor(Math.random() * 6) + 1;
                  playSound('dice');
                  shadowDiceRes.textContent = moveRoll;
                  await new Promise(resolve => setTimeout(resolve, 500));
                  for(let i=0; i<moveRoll; i++) {
                      if (battleStarted) break;
                      let path = findPath(shadow.position, players[currentPlayerIndex].position);
                      if (path && path.length > 1) {
                          shadow.position = path[1];
                          buildBoard();
                          await new Promise(resolve => setTimeout(resolve, 200));
                      }
                      if (shadow.position === players[currentPlayerIndex].position) {
                          startBattle(shadow);
                          battleStarted = true;
                          break;
                      }
                  }
                  if(battleStarted) break;
              }
          }
          shadowActionDisplay.style.display = 'none';
      }

      if (!battleStarted) {
          endTurnAndSwitchPlayer();
      }
  }

  function endTurnAndSwitchPlayer() {
      currentPlayerIndex = (currentPlayerIndex + 1) % numPlayers;
      updatePlayerInfo();
      updateDiscoveriesLog();
      buildBoard();
      updatePlayerActions();
      setMainMessage(`Tocca a ${players[currentPlayerIndex].name}!`, '#ffeb3b');
  }
  
  function handleEncounter(enemy) {
      playerActions.innerHTML = '';
      encounterModal.style.display = 'block';
      encounterMessage.textContent = 'Nemico! Scegli la tua azione.';
      encounterActionBtns.innerHTML = '';
      const rollBtn = document.createElement('button');
      rollBtn.textContent = 'Tenta di nasconderti (D6)';
      rollBtn.onclick = () => {
          rollBtn.disabled = true;
          battleBtn.disabled = true;
          let flips = 10;
          playSound('dice');
          const timer = setInterval(() => {
              encounterDiceResult.textContent = Math.floor(Math.random() * 6) + 1;
              if (--flips === 0) {
                  clearInterval(timer);
                  let roll = Number(encounterDiceResult.textContent);
                  let success = roll >= 4;
                  if (players[currentPlayerIndex].class === 'Ladro') {
                      success = roll >= 3;
                  }
                  encounterActionBtns.innerHTML = '';
                  const closeBtn = document.createElement('button');
                  if (success) {
                      encounterMessage.textContent = "Sei riuscito a nasconderti!";
                      closeBtn.textContent = "Chiudi e continua";
                      closeBtn.onclick = async () => {
                          encounterModal.style.display = 'none';
                          await endTurnSequence();
                      };
                  } else {
                      encounterMessage.textContent = "Sei stato visto! Inizia la battaglia.";
                      closeBtn.textContent = "Vai alla Battaglia";
                      closeBtn.onclick = () => {
                          encounterModal.style.display = 'none';
                          startBattle(enemy);
                      };
                  }
                  encounterActionBtns.appendChild(closeBtn);
              }
          }, 100);
      };
      const battleBtn = document.createElement('button');
      battleBtn.textContent = 'Vai in battaglia';
      battleBtn.onclick = () => {
          encounterModal.style.display = 'none';
          startBattle(enemy);
      };
      encounterActionBtns.appendChild(rollBtn);
      encounterActionBtns.appendChild(battleBtn);
  }
  
  function getFinalPrisonerMessage() {
    const totalPrisonersFreed = players.reduce((sum, p) => sum + (p.prisonersFreed || 0), 0);
    if (totalPrisonersFreed === 11) return `Prigionieri liberati: ${totalPrisonersFreed}. Siete stati portati a festa come eroi liberatori!`;
    if (totalPrisonersFreed >= 9) return `Prigionieri liberati: ${totalPrisonersFreed}. Un cittadino piange il figlio perduto sulla sua tomba.`;
    if (totalPrisonersFreed >= 5) return `Prigionieri liberati: ${totalPrisonersFreed}. I cittadini sono tristi per i prigionieri non liberati.`;
    return `Prigionieri liberati: ${totalPrisonersFreed}. I cittadini piangono i loro cari non liberati.`;
  }

  function handleGameOver(source, deadPlayer) {
      battleModal.style.display = 'none';
      initiativeModal.style.display = 'none';
      allyChoiceModal.style.display = 'none';
      supportAttackModal.style.display = 'none';
      playSound('death');
      stopSound('battle');
      stopSound('background');
      setBattleMode(false);

      const prisonerMessage = getFinalPrisonerMessage();
      
      const gameOverTitle = `GAME OVER\n${deadPlayer.name} è stato sconfitto ${source}.`;
      const gameOverSubtitle = `Nemici uccisi: ${enemiesDefeatedCount}\n${prisonerMessage}`;
      
      messageQueue.push({ endGame: true, title: gameOverTitle, subtitle: gameOverSubtitle });
      processMessageQueue();
  }

  function attemptEscape() {
      initiativeModal.style.display = 'none';
      battleModal.style.display = 'block';
      battleActionContainer.innerHTML = '';
      battleResult.innerHTML = 'Tenti la fuga...';
      battleResult.style.color = '#ffcc00';
      battleResult.style.fontSize = '18px';
      const character = players[activeBattleState.primaryCombatantIndex];
      let flips = 10;
      playSound('dice');
      const timer = setInterval(() => {
          let dieSize = character.class === 'Ladro' ? 4 : 6;
          battlePlayerDice.textContent = Math.floor(Math.random() * dieSize) + 1;
          if (--flips === 0) {
              clearInterval(timer);
              const damageRoll = Number(battlePlayerDice.textContent);
              playSound('hit');
              character.hp -= damageRoll;
              updatePlayerInfo();
              if (character.hp <= 0) {
                  handleGameOver("durante la fuga", character);
              } else {
                  battleModal.style.display = 'none';
                  setBattleMode(false);
                  messageQueue.push(`Fuga riuscita! Ma hai perso ${damageRoll} PF.`);
                  processMessageQueue(async () => await endTurnSequence());
              }
          }
      }, 100);
  }

  function startBattle(enemy) {
    setBattleMode(true);
    const character = players[currentPlayerIndex];
    if (!character) return;

    if (!enemy.isShadow) {
        if (enemy.isBoss) {
            enemy.startHP = 30; enemy.attackDie = 10; enemy.attackBonus = 2; enemy.defenseDie = 8; enemy.defenseBonus = 2;
        } else {
            const definition = ENEMY_DEFINITIONS[enemiesDefeatedCount];
            enemy = { ...enemy, ...definition, startHP: definition.hp, name: definition.name };
        }
    }
    const cellInfo = visitedCells.get(String(character.position));
    let currentEnemyHP = enemy.isShadow ? enemy.hp : (cellInfo && cellInfo.hp > 0 ? cellInfo.hp : enemy.startHP);
    if (cellInfo && !enemy.isShadow) cellInfo.hp = currentEnemyHP;

    activeBattleState = {
        enemy: { ...enemy, hp: currentEnemyHP, startHP: enemy.startHP },
        primaryCombatantIndex: currentPlayerIndex,
        battleCellNum: character.position,
        isAllyJoined: false,
        helpRequested: false,
        roundPhase: 'mainPlayer'
    };
    
    const otherPlayerIndex = (currentPlayerIndex + 1) % 2;
    if (numPlayers > 1 && players.length > 1 && players[otherPlayerIndex].position === character.position) {
        activeBattleState.isAllyJoined = true;
    }

    battleLog.textContent = 'Inizia la battaglia!';
    startCombatRound();
  }

  function startCombatRound() {
      if (!activeBattleState) return;
      if (activeBattleState.roundPhase === 'mainPlayer') {
          startInitiativePhase(false);
      } else if (activeBattleState.roundPhase === 'ally' && activeBattleState.isAllyJoined) {
          startInitiativePhase(true);
      } else {
          activeBattleState.roundPhase = 'mainPlayer';
          startInitiativePhase(false);
      }
  }


  function startInitiativePhase(isSupportRound) {
    if (!activeBattleState) return;
    battleModal.style.display = 'none';

    let combatant1, combatant2;
    if (isSupportRound) {
        combatant1 = players[(activeBattleState.primaryCombatantIndex + 1) % 2];
        combatant2 = activeBattleState.enemy;
        initiativeMessage.textContent = `Iniziativa Supporto: ${combatant1.name} vs ${combatant2.name}`;
    } else {
        combatant1 = players[activeBattleState.primaryCombatantIndex];
        combatant2 = activeBattleState.enemy;
        initiativeMessage.textContent = `Iniziativa: ${combatant1.name} vs ${combatant2.name}`;
    }

    initiativePlayerName.textContent = combatant1.name;
    initiativePlayerStats.textContent = `PF: ${combatant1.hp} | Energia: ${combatant1.energy}`;
    initiativeEnemyName.textContent = combatant2.name;
    initiativeEnemyStats.textContent = `PF: ${combatant2.hp}`;
    
    initiativePlayerDice.textContent = '-';
    initiativeEnemyDice.textContent = '-';
    initiativeResult.textContent = '';
    initiativeModal.style.display = 'block';
    initiativeRollBtn.style.display = 'block';
    initiativeRollBtn.disabled = false;
    
    usePotionInitiativeBtn.style.display = 'none';
    if (!isSupportRound) {
        usePotionInitiativeBtn.style.display = 'block';
        usePotionInitiativeBtn.disabled = combatant1.inventory.filter(p => p.type === 'heal' || p.type === 'energy').length === 0;
        usePotionInitiativeBtn.onclick = () => openInitiativePotionSelect();
    }

    initiativeRollBtn.onclick = () => {
        initiativeRollBtn.disabled = true;
        usePotionInitiativeBtn.style.display = 'none';
        
        animateAndRoll(initiativePlayerDice, 6, 0, (roll1) => {
            animateAndRoll(initiativeEnemyDice, 6, 0, (roll2) => {
                setTimeout(() => {
                    const winner = roll1 >= roll2 ? combatant1 : combatant2;
                    initiativeResult.textContent = `${winner.name} ha l'iniziativa!`;
                    
                    setTimeout(() => {
                        initiativeModal.style.display = 'none';
                        let attacker = winner;
                        let defender = (attacker === combatant1) ? combatant2 : combatant1;
                        prepareAttackPhase(attacker, defender, isSupportRound);
                    }, 2000);
                }, 2000); 
            });
        });
    };
  }

  function prepareAttackPhase(attacker, defender, isSupportRound) {
    if (!activeBattleState) return;
    
    battleModal.style.display = 'flex';
    updateBattleUI();

    const isPlayerAttacker = players.includes(attacker);
    battleResult.innerHTML = `Tocca a ${attacker.name} attaccare!`;
    battleActionContainer.innerHTML = '';
    specialAbilitiesContainer.innerHTML = '';
    
    if (isPlayerAttacker) {
        specialAbilitiesContainer.style.visibility = 'visible';
        
        const attackBtn = document.createElement('button');
        attackBtn.textContent = 'Attacco Normale';
        attackBtn.onclick = () => { 
            activeAbility = null;
            resolveAttack(attacker, defender); 
        };
        battleActionContainer.appendChild(attackBtn);

        if (!isSupportRound) {
            if (!defender.isShadow) {
                const escapeBtn = document.createElement('button');
                escapeBtn.textContent = `Fuggi (subisci 1D${attacker.class === 'Ladro' ? 4 : 6} PF)`;
                escapeBtn.onclick = attemptEscape;
                battleActionContainer.appendChild(escapeBtn);
            }

            const cost = attacker.class === 'Guerriero' ? 4 : 5;
            const powerStrikeBtn = document.createElement('button');
            powerStrikeBtn.id = 'powerStrikeBtn';
            powerStrikeBtn.title = 'Un attacco che non può essere parato';
            powerStrikeBtn.textContent = `Colpo Potente (${cost})`;
            powerStrikeBtn.onclick = () => { if (attacker.energy >= cost) { attacker.energy -= cost; activeAbility = 'powerStrike'; resolveAttack(attacker, defender); } };
            specialAbilitiesContainer.appendChild(powerStrikeBtn);

            const doubleAttackBtn = document.createElement('button');
            doubleAttackBtn.id = 'doubleAttackBtn';
            doubleAttackBtn.title = 'Esegui due tiri di attacco in un turno';
            doubleAttackBtn.textContent = `Doppio Attacco (${cost})`;
            doubleAttackBtn.onclick = () => { if (attacker.energy >= cost) { attacker.energy -= cost; activeAbility = 'doubleAttack'; resolveAttack(attacker, defender); } };
            specialAbilitiesContainer.appendChild(doubleAttackBtn);

             const usePotionBattleBtn = document.createElement('button');
             usePotionBattleBtn.textContent = 'Usa Pozione';
             usePotionBattleBtn.onclick = () => openBattlePotionSelect(attacker);
             specialAbilitiesContainer.appendChild(usePotionBattleBtn);
            
            if (numPlayers > 1 && !activeBattleState.isAllyJoined && !activeBattleState.helpRequested) {
                const askHelpBtn = document.createElement('button');
                askHelpBtn.textContent = 'Chiedi Soccorso';
                askHelpBtn.classList.add('intervention-btn');
                askHelpBtn.onclick = askForHelp;
                specialAbilitiesContainer.appendChild(askHelpBtn);
            }
        } else { // Alleato attaccante
            const usePotionBattleBtn = document.createElement('button');
             usePotionBattleBtn.textContent = 'Usa Pozione';
             usePotionBattleBtn.onclick = () => openBattlePotionSelect(attacker);
             specialAbilitiesContainer.appendChild(usePotionBattleBtn);
        }
        updateEnergyUI();
    } else { // Turno del nemico
        specialAbilitiesContainer.style.visibility = 'hidden';
        setTimeout(() => resolveAttack(attacker, defender), 2000);
    }
  }
  
  function updateBattleUI() {
    if (!activeBattleState) return;
    const mainPlayer = players[activeBattleState.primaryCombatantIndex];
    const enemy = activeBattleState.enemy;

    // Main Player
    battlePlayerName.textContent = mainPlayer.name;
    battlePlayerPF.textContent = `PF: ${Math.max(0, mainPlayer.hp)} / ${mainPlayer.maxHP}`;
    const mainPlayerAttackBonus = getAttackBonus(mainPlayer, enemy.isShadow) + (mainPlayer.hasSpecialSword ? 1 : 0);
    const mainPlayerAttackDie = mainPlayer.hasSpecialSword ? 12 : mainPlayer.attackDie;
    battlePlayerAttack.textContent = `Attacco: 1D${mainPlayerAttackDie}${mainPlayerAttackBonus >= 0 ? '+' + mainPlayerAttackBonus : mainPlayerAttackBonus}`;
    battlePlayerDefense.textContent = `Difesa: 1D${mainPlayer.defenseDie}${getDefenseBonus(mainPlayer) > 0 ? '+' + getDefenseBonus(mainPlayer) : ''}`;

    // Ally
    if (activeBattleState.isAllyJoined && numPlayers > 1) {
        const allyPlayer = players[(activeBattleState.primaryCombatantIndex + 1) % 2];
        allyBattleUnit.style.display = 'block';
        allyJoinedIndicator.style.display = 'block';
        battleAllyName.textContent = allyPlayer.name;
        battleAllyPF.textContent = `PF: ${Math.max(0, allyPlayer.hp)} / ${allyPlayer.maxHP}`;
        const allyAttackBonus = getAttackBonus(allyPlayer, enemy.isShadow) + (allyPlayer.hasSpecialSword ? 1 : 0);
        const allyAttackDie = allyPlayer.hasSpecialSword ? 12 : allyPlayer.attackDie;
        battleAllyAttack.textContent = `Attacco: 1D${allyAttackDie}${allyAttackBonus >= 0 ? '+' + allyAttackBonus : allyAttackBonus}`;
        battleAllyDefense.textContent = `Difesa: 1D${allyPlayer.defenseDie}${getDefenseBonus(allyPlayer) > 0 ? '+' + getDefenseBonus(allyPlayer) : ''}`;
    } else {
        allyBattleUnit.style.display = 'none';
        allyJoinedIndicator.style.display = 'none';
    }
    
    // Enemy
    battleEnemyName.textContent = enemy.name;
    battleEnemyPF.textContent = `PF: ${Math.max(0, enemy.hp)} / ${enemy.startHP}`;
    battleEnemyAttack.textContent = `Attacco: 1D${enemy.attackDie}+${enemy.attackBonus || 0}`;
    battleEnemyDefense.textContent = `Difesa: 1D${enemy.defenseDie}+${enemy.defenseBonus || 0}`;

    battlePlayerDice.textContent = '-';
    battleAllyDice.textContent = '-';
    battleEnemyDice.textContent = '-';
    updateEnergyUI();
  }

  function animateMainDice(callback) {
      playSound('dice');
      let flips = 10;
      const timer = setInterval(() => {
          diceRes.textContent = Math.floor(Math.random() * 6) + 1;
          if (--flips === 0) {
              clearInterval(timer);
              const finalRoll = Math.floor(Math.random() * 6) + 1;
              diceRes.textContent = finalRoll;
              callback(finalRoll);
          }
      }, 100);
  }

  function animateAndRoll(targetEl, die, bonus, callback) {
        playSound('dice');
        let flips = 10;
        const timer = setInterval(() => {
            targetEl.textContent = Math.floor(Math.random() * die) + 1;
            if (--flips === 0) {
                clearInterval(timer);
                const roll = Math.floor(Math.random() * die) + 1;
                const total = roll + bonus;
                targetEl.textContent = total;
                callback(total);
            }
        }, 80);
    }
    
  function resolveAttack(attacker, defender) {
    battleActionContainer.innerHTML = '';
    specialAbilitiesContainer.style.visibility = 'hidden';
    
    const isPlayerAttacker = players.includes(attacker);
    
    const getAttackerAttackDie = () => isPlayerAttacker ? (attacker.hasSpecialSword ? 12 : attacker.attackDie) : attacker.attackDie;
    const getAttackerAttackBonus = () => isPlayerAttacker ? getAttackBonus(attacker, defender.isShadow) : (attacker.attackBonus || 0);
    const getDefenderDefenseDie = () => players.includes(defender) ? defender.defenseDie : defender.defenseDie;
    const getDefenderDefenseBonus = () => players.includes(defender) ? getDefenseBonus(defender) : (defender.defenseBonus || 0);
    
    let attackerDiceEl, defenderDiceEl;
    if (isPlayerAttacker) {
        attackerDiceEl = (attacker === players[activeBattleState.primaryCombatantIndex]) ? battlePlayerDice : battleAllyDice;
        defenderDiceEl = battleEnemyDice;
    } else {
        attackerDiceEl = battleEnemyDice;
        defenderDiceEl = (defender === players[activeBattleState.primaryCombatantIndex]) ? battlePlayerDice : battleAllyDice;
    }


    function processCombatResult(attackRoll, defenseRoll) {
        setTimeout(() => {
            const damage = Math.max(0, attackRoll - defenseRoll);
            defender.hp -= damage;
            battleLog.textContent += `\n${attacker.name} (Atk: ${attackRoll}) vs ${defender.name} (Def: ${defenseRoll}).`;
            if (damage > 0) {
                if (damage >= 3) {
                    playSound('powerhit');
                } else {
                    playSound('hit');
                }
                if (damage >= 3) triggerScreenShake();
                battleResult.innerHTML = `${defender.name} subisce ${damage} danni!`;
                battleResult.style.color = players.includes(defender) ? 'red' : 'lightgreen';
            } else {
                playSound('parry');
                battleResult.innerHTML = `Attacco parato!`;
                battleResult.style.color = 'deepskyblue';
            }
            setTimeout(finalizePhase, 2000);
        }, 2000);
    }

     if (activeAbility === 'doubleAttack' && isPlayerAttacker) {
        let totalDamage = 0; let logText = "";
        animateAndRoll(attackerDiceEl, getAttackerAttackDie(), getAttackerAttackBonus(), (attack1) => {
            animateAndRoll(defenderDiceEl, getDefenderDefenseDie(), getDefenderDefenseBonus(), (defense1) => {
                setTimeout(() => {
                    const damage1 = Math.max(0, attack1 - defense1); 
                    if(damage1 > 0) { if(damage1 >= 3) playSound('powerhit'); else playSound('hit'); }
                    if (damage1 >= 3) triggerScreenShake(); totalDamage += damage1; logText += `\nAttacco 1: ${attack1} vs ${defense1}. Danno: ${damage1}`;
                    setTimeout(() => {
                        animateAndRoll(attackerDiceEl, getAttackerAttackDie(), getAttackerAttackBonus(), (attack2) => {
                            animateAndRoll(defenderDiceEl, getDefenderDefenseDie(), getDefenderDefenseBonus(), (defense2) => {
                                 setTimeout(() => {
                                    const damage2 = Math.max(0, attack2 - defense2);
                                    if(damage2 > 0) { if(damage2 >= 3) playSound('powerhit'); else playSound('hit'); }
                                    if (damage2 >= 3) triggerScreenShake(); totalDamage += damage2; logText += `\nAttacco 2: ${attack2} vs ${defense2}. Danno: ${damage2}`; defender.hp -= totalDamage; battleLog.textContent += logText; battleResult.innerHTML = `Doppio Attacco! Danno Totale: ${totalDamage}`;
                                    setTimeout(finalizePhase, 2000);
                                }, 2000);
                            });
                        });
                    }, 1000);
                }, 2000);
            });
        });
    } else if (activeAbility === 'powerStrike' && isPlayerAttacker) {
        animateAndRoll(attackerDiceEl, getAttackerAttackDie(), getAttackerAttackBonus(), (attackRoll) => {
            defenderDiceEl.textContent = 'X';
             setTimeout(() => {
                playSound('powerhit');
                if (attackRoll >= 3) triggerScreenShake(); defender.hp -= attackRoll; battleLog.textContent += `\nColpo Potente! L'attacco ignora la difesa.`; battleResult.innerHTML = `Danno inflitto: ${attackRoll}`;
                setTimeout(finalizePhase, 2000);
            }, 2000);
        });
    } else {
        animateAndRoll(attackerDiceEl, getAttackerAttackDie(), getAttackerAttackBonus(), (attackRoll) => {
            animateAndRoll(defenderDiceEl, getDefenderDefenseDie(), getDefenderDefenseBonus(), (defenseRoll) => {
                processCombatResult(attackRoll, defenseRoll);
            });
        });
    }
  }
  
  function finalizePhase() {
    if (!activeBattleState) return;
    activeAbility = null;
    updateBattleUI();

    for (const player of players) {
      if (player.hp <= 0) {
        setTimeout(() => handleGameOver("in combattimento", player), 1500);
        return;
      }
    }
    if (activeBattleState.enemy.hp <= 0) {
        setTimeout(() => endBattleVictoriously(), 1500);
        return;
    }

    if (activeBattleState.roundPhase === 'mainPlayer') {
        activeBattleState.roundPhase = 'ally';
    } else {
        activeBattleState.roundPhase = 'mainPlayer';
    }
    startCombatRound();
  }

  function endBattleVictoriously(){
    const combatant = players[activeBattleState.primaryCombatantIndex];
    const enemy = activeBattleState.enemy;
    gainEnergy(3);
    playSound('death');
    battleResult.innerHTML = "VITTORIA!<br>Hai sconfitto il nemico.";
    battleResult.style.color = 'lightgreen';
    if (enemy.isShadow) {
        shadows = shadows.filter(s => s.name !== enemy.name);
    } else {
        const cellInfo = visitedCells.get(String(combatant.position));
        cellInfo.defeated = true;
        if (enemy.isBoss) {
            messageQueue.push({ victory: true, title: "Dungeon liberato!", subtitle: "Hai sconfitto il Boss Finale!", prisonerStatus: getFinalPrisonerMessage() });
            processMessageQueue(() => { setBattleMode(false); });
            return;
        } else {
            enemiesDefeatedCount++;
            if (enemiesDefeatedCount === ENEMY_COUNT) placeBoss();
        }
    }
    updateDiscoveriesLog();
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Continua...';
    closeBtn.onclick = async () => {
        battleModal.style.display = 'none';
        setBattleMode(false);
        await endTurnSequence();
    };
    battleActionContainer.innerHTML = '';
    specialAbilitiesContainer.innerHTML = '';
    battleActionContainer.appendChild(closeBtn);
  }
  
  function askForHelp() {
      if (!activeBattleState) return;
      activeBattleState.helpRequested = true;
      battleActionContainer.innerHTML = '';
      specialAbilitiesContainer.innerHTML = '';
      battleResult.innerHTML = 'Hai chiesto aiuto...';
      
      currentPlayerIndex = (currentPlayerIndex + 1) % numPlayers;
      updatePlayerInfo();
      updatePlayerActions();
  }

  function showAllyChoiceModal() {
      battleModal.style.display = 'none';
      allyChoiceModal.style.display = 'block';
  }

  function updatePlayerActions() {
      playerActions.innerHTML = '';
      const diceButton = document.createElement('button');
      diceButton.id = 'diceRollBtn';
      diceButton.textContent = 'Tira dado';
      diceButton.onclick = rollDice;
      playerActions.appendChild(diceButton);
      
      hideTradeButton();
      if (numPlayers > 1 && players.length > 1 && players[0].position === players[1].position) {
        showTradeButton();
      }

      if (activeBattleState) {
          diceButton.disabled = true;
          if (currentPlayerIndex !== activeBattleState.primaryCombatantIndex && activeBattleState.helpRequested) {
              showAllyChoiceModal();
              allyChoiceMessage.textContent = `${players[activeBattleState.primaryCombatantIndex].name} chiede il tuo aiuto! Cosa fai?`;
              allyChoiceActions.innerHTML = '';

              const interveneBtn = document.createElement('button');
              interveneBtn.textContent = 'Intervieni';
              interveneBtn.classList.add('intervention-btn');
              interveneBtn.onclick = () => {
                  attemptIntervention();
              };
              allyChoiceActions.appendChild(interveneBtn);

              const ignoreBtn = document.createElement('button');
              ignoreBtn.textContent = 'Ignora';
              ignoreBtn.classList.add('ignore-btn');
              ignoreBtn.onclick = () => {
                  activeBattleState.helpRequested = false;
                  setMainMessage('Hai ignorato la richiesta di aiuto.', 'orange');
                  currentPlayerIndex = activeBattleState.primaryCombatantIndex;
                  updatePlayerInfo();
                  allyChoiceModal.style.display = 'none';
                  startCombatRound();
              };
              allyChoiceActions.appendChild(ignoreBtn);

          }
      }
  }

  async function attemptIntervention() {
    allyChoiceActions.innerHTML = '';
    const ally = players[currentPlayerIndex];
    const battleCellNum = activeBattleState.battleCellNum;
    const path = findPath(ally.position, battleCellNum);
    const distance = path ? path.length - 1 : -1;

    if (distance <= 0) {
        allyChoiceModal.style.display = 'none';
        messageQueue.push("Sei già sul posto! Ti unisci alla lotta.");
        processMessageQueue(() => {
            activeBattleState.isAllyJoined = true;
            activeBattleState.helpRequested = false;
            currentPlayerIndex = activeBattleState.primaryCombatantIndex;
            updatePlayerInfo();
            startCombatRound();
        });
        return;
    }

    allyChoiceMessage.textContent = `Ti serve un ${distance} o più per raggiungere la battaglia!`;
    const rollBtn = document.createElement('button');
    rollBtn.textContent = 'Lancia per Intervenire';
    allyChoiceActions.appendChild(rollBtn);

    rollBtn.onclick = () => {
        rollBtn.disabled = true;
        allyChoiceMessage.textContent = `Lancio in corso...`;
        animateMainDice(async (roll) => {
            allyChoiceMessage.textContent = `Hai ottenuto: ${roll}`;
            await new Promise(resolve => setTimeout(resolve, 2000));

            if (roll >= distance) {
                allyChoiceModal.style.display = 'none';
                messageQueue.push("Sei arrivato in tempo! Ti unisci alla lotta.");
                const movePath = path;
                for (let i = 1; i < movePath.length; i++) {
                    await new Promise(resolve => setTimeout(resolve, 150));
                    playSound('step');
                    ally.position = movePath[i];
                    buildBoard();
                }
                activeBattleState.isAllyJoined = true;
                activeBattleState.helpRequested = false;
                processMessageQueue(() => {
                    currentPlayerIndex = activeBattleState.primaryCombatantIndex;
                    updatePlayerInfo();
                    startCombatRound();
                });
            } else {
                allyChoiceModal.style.display = 'none';
                messageQueue.push(`Non sei abbastanza veloce! Percorri ${roll} caselle ma la battaglia continua senza di te.`);
                const movePath = path.slice(0, roll + 1);
                if (movePath.length > 1) {
                  for (let i = 1; i < movePath.length; i++) {
                      await new Promise(resolve => setTimeout(resolve, 150));
                      playSound('step');
                      ally.position = movePath[i];
                      buildBoard();
                  }
                }
                activeBattleState.helpRequested = false;
                processMessageQueue(() => {
                    currentPlayerIndex = activeBattleState.primaryCombatantIndex;
                    updatePlayerInfo();
                    startCombatRound();
                });
            }
        });
    };
  }


  function updatePlayerInfo() {
      if (players.length === 0 || !players[currentPlayerIndex]) { playerInfo.textContent = 'Crea un personaggio'; energyValue.textContent = '0'; return; }
      const character = players[currentPlayerIndex]; playerInfo.textContent = `${character.name} (G${currentPlayerIndex+1}) | PF: ${Math.max(0, character.hp)} / ${character.maxHP}`; playerInfo.className = `player-1-info`; if (currentPlayerIndex === 1) playerInfo.className = `player-2-info`; updateEnergyUI();
  }

  function wireCellListeners() { board.addEventListener('click', event => { const target = event.target.closest('.cell'); if (target && target.classList.contains('highlighted')) { animateAndSetCurrent(target); } }); }
  
  function rollDice() {
    const btn = document.getElementById('diceRollBtn');
    if (!btn || btn.disabled) return;
    btn.disabled = true;
    resetMessages();
    animateMainDice((roll) => {
        const moves = getValidMoves(roll);
        if (moves.length === 0) {
            triggerScreenShake();
            playSound('vines');
            const character = players[currentPlayerIndex];
            const damage = character.class === 'Esploratore' ? 1 : 3;
            messageQueue.push(`Sei bloccato da delle rampicanti che ti infliggono ${damage} PF`);
            processMessageQueue(() => {
                character.hp -= damage;
                updatePlayerInfo();
                if (character.hp <= 0) {
                    handleGameOver("intrappolato dai rampicanti", character);
                } else {
                    setTimeout(() => endTurnSequence(), 500);
                }
            });
        } else {
            moves.forEach(cell => cell.classList.add('highlighted'));
        }
    });
  }
  
  async function startGame() {
      players.forEach(p => { p.position = 1; p.bonuses = p.bonuses || []; p.inventory = p.inventory || []; p.hasSpecialSword = p.hasSpecialSword || false; p.prisonersFreed = p.prisonersFreed || 0; p.isCursed = p.isCursed || false; p.shadowSlayerBonus = p.shadowSlayerBonus || 0; p.activeQuests = p.activeQuests || []; });
      visitedCells = new Map(); enemiesDefeatedCount = 0; discoveryCounter = 1; gasEffect = { active: false, newCellsVisited: 0 }; shadows = []; spawnedShadows = new Set(); messageQueue = [];
      placeDiscoveries(); buildBoard();
      const firstPlayer = players[0]; const startCell = board.querySelector(`[data-cell-number="${firstPlayer.position}"]`);
      processCellLogic(startCell);
      updateLayout(); updatePlayerInfo(); updateDiscoveriesLog(); charForm.style.display = 'none';
  }
  
  function promptForNewGame() {
      resetMessages(); board.innerHTML = ''; discoveriesLog.textContent = ''; players = []; currentPlayerIndex = 0; activeBattleState = null; updatePlayerInfo(); diceRes.textContent = '-'; updatePlayerActions();
      const numInput = prompt("Quanti giocatori? (1 o 2)", "1"); numPlayers = (numInput === '2') ? 2 : 1;
      creatingPlayerIndex = 0; showCharacterCreationForm();
  }

  function showCharacterCreationForm() {
    charFormTitle.textContent = `Crea Personaggio per Giocatore ${creatingPlayerIndex + 1}`;
    document.getElementById('charName').value = '';
    const charHPInput = document.getElementById('charHP');
    charHPInput.value = 35; 
    charForm.style.display = 'block';
  }


  function saveGame() {
      if (players.length === 0) { alert("Nessun gioco da salvare. Inizia una nuova partita prima."); return; }
      const gameState = { players, currentPlayerIndex, numPlayers, enemiesDefeatedCount, discoveryCounter, visitedCells: Array.from(visitedCells.entries()), enemyMap, bonusMap, potionMap, prisonerMap, altarMap, gasTrapPositions: Array.from(gasTrapPositions), gasActivatedPositions: Array.from(gasActivatedPositions), holePositions: Array.from(holePositions), gasEffect, shadows, spawnedShadows: Array.from(spawnedShadows), prisonerQuests, activeBattleState };
      localStorage.setItem('dungeon72Save', JSON.stringify(gameState)); alert('Partita salvata!'); loadGameBtn.style.display = 'block';
  }

  async function loadGame() {
      if (!audioInitialized) initAudio();
      const savedStateJSON = localStorage.getItem('dungeon72Save'); if (!savedStateJSON) { promptForNewGame(); return; }
      const savedState = JSON.parse(savedStateJSON);
      players = savedState.players; currentPlayerIndex = savedState.currentPlayerIndex; numPlayers = savedState.numPlayers; enemiesDefeatedCount = savedState.enemiesDefeatedCount; discoveryCounter = savedState.discoveryCounter; visitedCells = new Map(savedState.visitedCells);
      enemyMap = savedState.enemyMap; bonusMap = savedState.bonusMap; potionMap = savedState.potionMap; prisonerMap = savedState.prisonerMap; altarMap = savedState.altarMap; gasTrapPositions = new Set(savedState.gasTrapPositions); gasActivatedPositions = new Set(savedState.gasActivatedPositions); holePositions = new Set(savedState.holePositions); gasEffect = savedState.gasEffect; shadows = savedState.shadows; spawnedShadows = new Set(savedState.spawnedShadows); prisonerQuests = savedState.prisonerQuests; activeBattleState = savedState.activeBattleState;
      messageQueue = []; buildBoard(); updateLayout(); updatePlayerInfo(); updateDiscoveriesLog(); resetMessages(); charForm.style.display = 'none';
      if (activeBattleState) { setBattleMode(true); startCombatRound(); }
      else { updatePlayerActions(); }
      alert('Partita caricata!');
  }

  function updateLayout() { const discoveriesLog = document.getElementById('discoveriesLog'); const leftColumn = document.getElementById('left'); const centerColumn = document.getElementById('center-column'); const isDesktop = window.innerWidth > 1024; if (isDesktop) { if (discoveriesLog.parentElement !== leftColumn) { leftColumn.appendChild(discoveriesLog); } } else { if (discoveriesLog.parentElement !== centerColumn) { centerColumn.appendChild(discoveriesLog); } } }
  
  function openBattlePotionSelect(player) {
      if (!activeBattleState) return;
      battlePotionList.innerHTML = '';
      if (player.inventory.length === 0) return;
      player.inventory.forEach((potion, index) => { 
          const btn = document.createElement('button'); 
          btn.textContent = potion.name; 
          btn.onclick = () => { battlePotionSelectModal.style.display = 'none'; usePotionInBattle(potion, index, player); }; 
          battlePotionList.appendChild(btn); 
      });
      battlePotionSelectModal.style.display = 'block';
  }

  function openInitiativePotionSelect() {
      if (!activeBattleState) return;
      const character = players[activeBattleState.primaryCombatantIndex]; battlePotionList.innerHTML = ''; const usablePotions = character.inventory.map((potion, index) => ({...potion, originalIndex: index})).filter(p => p.type === 'heal' || p.type === 'energy');
      if (usablePotions.length === 0) return;
      usablePotions.forEach((potion) => { const btn = document.createElement('button'); btn.textContent = potion.name; btn.onclick = () => { battlePotionSelectModal.style.display = 'none'; usePotionInInitiative(potion, potion.originalIndex); }; battlePotionList.appendChild(btn); });
      battlePotionSelectModal.style.display = 'block';
  }
  
  function usePotionInInitiative(potion, index){
      const character = players[activeBattleState.primaryCombatantIndex]; character.inventory.splice(index, 1); let logMessage = '';
      if (potion.type === 'heal') { const oldHp = character.hp; character.hp = Math.min(character.hp + potion.value, character.maxHP); const healedAmount = character.hp - oldHp; logMessage = `${character.name} usa ${potion.name} e recupera ${healedAmount} PF!`; }
      else if (potion.type === 'energy') { character.energy = character.maxEnergy; logMessage = `${character.name} usa ${potion.name} e recupera tutta l'energia!`; }
      updatePlayerInfo(); updateDiscoveriesLog(); initiativePlayerStats.textContent = `PF: ${character.hp} | Energia: ${character.energy}`; initiativeResult.textContent = logMessage; setTimeout(() => { if (initiativeResult.textContent === logMessage) { initiativeResult.textContent = ''; } }, 2000); usePotionInitiativeBtn.disabled = character.inventory.filter(p => p.type === 'heal' || p.type === 'energy').length === 0;
  }
  
  function usePotionInBattle(potion, index, player) {
      if (!activeBattleState) return;
      player.inventory.splice(index, 1);
      if (potion.type === 'heal') { const oldHp = player.hp; player.hp = Math.min(player.hp + potion.value, player.maxHP); const healedAmount = player.hp - oldHp; updateBattleUI(); updateDiscoveriesLog(); battleLog.textContent += `\n${player.name} usa ${potion.name} e recupera ${healedAmount} PF!`; battleResult.innerHTML = `Ora ha ${player.hp} PF.`; setTimeout(finalizePhase, 2000); }
      else if (potion.type === 'fire' || potion.type === 'ice') {
           potionDamageModal.style.display = 'block'; potionDamageTitle.textContent = `Usa ${potion.name}`; potionDamageDice.textContent = '-'; potionDamageRollBtn.disabled = false;
           potionDamageRollBtn.onclick = () => {
               potionDamageRollBtn.disabled = true; let flips = 10;
               playSound('dice');
               const timer = setInterval(() => { potionDamageDice.textContent = Math.floor(Math.random() * 6) + 1; if (--flips === 0) { clearInterval(timer); const damage = Number(potionDamageDice.textContent); potionDamageModal.style.display = 'none'; const enemy = activeBattleState.enemy; playSound('hit'); if (damage >= 3) triggerScreenShake(); enemy.hp -= damage; let log = `\n${potion.name} infligge ${damage} danni!`; if (potion.type === 'fire') { enemy.effects = enemy.effects || []; enemy.effects = enemy.effects.filter(e => e.type !== 'burn'); enemy.effects.push({ type: 'burn', duration: 2, damage: [3, 2] }); log += `\nIl nemico sta andando a fuoco!`; } else if (potion.type === 'ice') { const heroAttackRoll = Math.floor(Math.random() * (player.hasSpecialSword ? 12 : player.attackDie) + 1) + getAttackBonus(player, enemy.isShadow); playSound('hit'); if (heroAttackRoll >= 3) triggerScreenShake(); enemy.hp -= heroAttackRoll; log += `\nIl nemico è congelato e subisce un colpo extra da ${heroAttackRoll} danni!`; } battleLog.textContent += log; updateDiscoveriesLog(); setTimeout(finalizePhase, 2000); } }, 100);
           }
      }
  }

  function showTradeButton() {
    let tradeBtn = document.getElementById('tradeBtn');
    if (!tradeBtn) {
        tradeBtn = document.createElement('button');
        tradeBtn.id = 'tradeBtn';
        tradeBtn.textContent = 'Scambia Oggetti';
        tradeBtn.onclick = openTradeModal;
        stickyControls.appendChild(tradeBtn);
    }
    tradeBtn.style.display = 'inline-block';
  }

  function hideTradeButton() {
    const tradeBtn = document.getElementById('tradeBtn');
    if (tradeBtn) {
        tradeBtn.style.display = 'none';
    }
  }

  function openTradeModal() {
    if(numPlayers < 2) return;
    updateTradeInventories();
    tradeModal.style.display = 'flex';
  }

  function updateTradeInventories() {
    player1InventoryList.innerHTML = '';
    player2InventoryList.innerHTML = '';
    if(players.length < 2) return;
    document.getElementById('tradePlayer1Name').textContent = players[0].name;
    document.getElementById('tradePlayer2Name').textContent = players[1].name;
    
    let allItems1 = [...players[0].inventory.map((item, index) => ({...item, source: 'inventory', originalIndex: index})), ...players[0].bonuses.map((item, index) => ({...item, source: 'bonuses', originalIndex: index}))];
    let allItems2 = [...players[1].inventory.map((item, index) => ({...item, source: 'inventory', originalIndex: index})), ...players[1].bonuses.map((item, index) => ({...item, source: 'bonuses', originalIndex: index}))];

    allItems1.forEach(item => {
        if(item.name === GEM_DOOR.name) return;
        const li = document.createElement('li');
        li.textContent = item.name;
        li.dataset.itemName = item.name;
        li.dataset.source = item.source;
        li.dataset.player = 0;
        player1InventoryList.appendChild(li);
    });

    allItems2.forEach(item => {
        if(item.name === GEM_DOOR.name) return;
        const li = document.createElement('li');
        li.textContent = item.name;
        li.dataset.itemName = item.name;
        li.dataset.source = item.source;
        li.dataset.player = 1;
        player2InventoryList.appendChild(li);
    });
    selectedTradeItem = null;
    toPlayer1Btn.disabled = true;
    toPlayer2Btn.disabled = true;
  }

  function handleTradeSelection(e) {
    const target = e.target;
    if (target.tagName !== 'LI') return;

    document.querySelectorAll('#tradeModal .inventory-list li').forEach(li => li.classList.remove('selected'));
    
    target.classList.add('selected');
    selectedTradeItem = target;

    const fromPlayerIndex = parseInt(target.dataset.player);
    toPlayer1Btn.disabled = (fromPlayerIndex === 0);
    toPlayer2Btn.disabled = (fromPlayerIndex === 1);
  }

  function transferItem(toIndex) {
    if (!selectedTradeItem) return;

    const fromIndex = parseInt(selectedTradeItem.dataset.player);
    const itemName = selectedTradeItem.dataset.itemName;
    const source = selectedTradeItem.dataset.source;

    let fromPlayerItems, toPlayerItems;
    if (source === 'inventory') {
        fromPlayerItems = players[fromIndex].inventory;
        toPlayerItems = players[toIndex].inventory;
    } else {
        fromPlayerItems = players[fromIndex].bonuses;
        toPlayerItems = players[toIndex].bonuses;
    }
    
    const itemIndex = fromPlayerItems.findIndex(item => item.name === itemName);

    if (itemIndex > -1) {
        const [itemToTransfer] = fromPlayerItems.splice(itemIndex, 1);
        toPlayerItems.push(itemToTransfer);
    }
    
    updateTradeInventories();
    updateDiscoveriesLog();
  }
  
  player1InventoryList.addEventListener('click', handleTradeSelection);
  player2InventoryList.addEventListener('click', handleTradeSelection);
  toPlayer1Btn.addEventListener('click', () => { if(selectedTradeItem && selectedTradeItem.dataset.player === '1') transferItem(0); });
  toPlayer2Btn.addEventListener('click', () => { if(selectedTradeItem && selectedTradeItem.dataset.player === '0') transferItem(1); });
  closeTradeBtn.addEventListener('click', () => { tradeModal.style.display = 'none'; updateDiscoveriesLog(); });
  
  newGameBtn.addEventListener('click', promptForNewGame);
  saveGameBtn.addEventListener('click', saveGame);
  loadGameBtn.addEventListener('click', loadGame);
  cancelCharBtn.addEventListener('click', () => { charForm.style.display = 'none'; });
  closeBattlePotionSelectBtn.addEventListener('click', () => { battlePotionSelectModal.style.display = 'none'; });

  startAdventureBtn.addEventListener('click', () => {
    const name = document.getElementById('charName').value.trim();
    const hpInput = document.getElementById('charHP').value;
    const charClass = document.getElementById('charClass').value;
    if (name && hpInput) {
        let hp = parseInt(hpInput);
        let energy = 0;
        let maxEnergy = 10;

        if (charClass === 'Guerriero') {
            hp += 10; 
            energy = 5;
            maxEnergy = 12;
        }

        players[creatingPlayerIndex] = {
            name, hp, maxHP: hp, class: charClass, attackDie: 10, defenseDie: 6, bonuses: [], inventory: [], hasSpecialSword: false, prisonersFreed: 0, energy, maxEnergy, isCursed: false, shadowSlayerBonus: 0, activeQuests: [], position: 1
        };
        creatingPlayerIndex++;
        if (creatingPlayerIndex < numPlayers) {
            showCharacterCreationForm();
        } else {
            startGame();
        }
    } else {
        alert('Inserisci un nome valido e i PF.');
    }
  });


  function init() {
      // Aggiunge gli event listener per sbloccare l'audio alla prima interazione
      window.addEventListener('click', initAudio, { once: true });
      window.addEventListener('touchstart', initAudio, { once: true });

      wireCellListeners();
      if (localStorage.getItem('dungeon72Save')) { loadGameBtn.style.display = 'block'; }
      window.addEventListener('resize', updateLayout);
      updateLayout();
      promptForNewGame();
  }

  init();
</script>
</body>
</html>
